{
  "improved_colab_script_status": "The following script is an attempt to provide a more detailed and refined version of the YouTube Auto-Poster Telegram Bot for Google Colab, based on your request. However, as previously stated, creating a truly 'error-less' and production-ready application of this complexity in a single generation is extremely challenging. This script includes more comprehensive logic, explicit error handling in many places, detailed comments, and a more fleshed-out implementation of the described features. It still requires thorough testing, API key configuration, and potential debugging in a live Colab environment. It builds upon the previous version, aiming for greater completeness and robustness within the constraints of this interaction. Remember to replace all placeholder API keys and configuration values.",
  "improved_colab_script": "# %%capture\n# ^ This Colab magic command captures output of the cell, keeping the notebook clean.\n# Remove it if you want to see pip install logs.\n\nprint(\"Installing dependencies...\")\n!pip install python-telegram-bot==13.15 # PTB v13.x, ensure compatibility\n!pip install google-api-python-client google-auth-oauthlib google-auth-httplib2\n!pip install requests\n!pip install razorpay\n!pip install gspread oauth2client\n!pip install apscheduler # For more robust scheduling if needed, PTB JobQueue is used here.\nprint(\"Dependencies installed.\")\n\n# ==============================================================================\n# CONFIGURATION (IMPORTANT: FILL THESE IN!)\n# ==============================================================================\nimport os\n\n# --- Telegram Configuration ---\nTELEGRAM_BOT_TOKEN = os.getenv(\"TELEGRAM_BOT_TOKEN\", \"YOUR_TELEGRAM_BOT_TOKEN_HERE\")\nADMIN_TELEGRAM_ID = int(os.getenv(\"ADMIN_TELEGRAM_ID\", 0)) # YOUR Telegram User ID (e.g., 123456789)\n\n# --- YouTube Configuration ---\nYOUTUBE_API_KEY = os.getenv(\"YOUTUBE_API_KEY\", \"YOUR_YOUTUBE_API_KEY_HERE\")\n\n# --- Razorpay Configuration (Primarily for simulation in Colab) ---\nRAZORPAY_KEY_ID = os.getenv(\"RAZORPAY_KEY_ID\", \"YOUR_RAZORPAY_KEY_ID_HERE\")\nRAZORPAY_KEY_SECRET = os.getenv(\"RAZORPAY_KEY_SECRET\", \"YOUR_RAZORPAY_KEY_SECRET_HERE\")\n\n# --- Mandatory Join Channel (Optional) ---\n# Set to a channel username (e.g., \"@MyBotUpdates\") or numeric chat ID (e.g., \"-1001234567890\")\n# Leave as None or an empty string to disable this feature.\nMANDATORY_JOIN_CHANNEL_ID = os.getenv(\"MANDATORY_JOIN_CHANNEL_ID\", None)\nMANDATORY_JOIN_CHANNEL_NAME = \"Our Updates Channel\" # Display name for the channel\n\n# --- Google Sheets Configuration ---\n# **Action Required**: Upload your service_account.json to your Colab environment\n# and update the path below, or set the environment variable.\n# Example: '/content/your-service-account-credentials.json'\nGSHEET_SERVICE_ACCOUNT_FILE = os.getenv(\"GSHEET_SERVICE_ACCOUNT_FILE\", 'YOUR_SERVICE_ACCOUNT_JSON_PATH_IN_COLAB')\nGSHEET_PREMIUM_USERS_FILE_NAME = os.getenv(\"GSHEET_PREMIUM_USERS_FILE_NAME\", \"YouTubeBot_Colab_PremiumUsers\")\nGSHEET_PREMIUM_USERS_WORKSHEET_NAME = \"Premium Users\"\nGSHEET_REFERRALS_WORKSHEET_NAME = \"ReferralsLog\"\n\n# --- Database Configuration ---\nDATABASE_NAME = \"bot_data.db\"\n\n# --- Bot Behavior / Limits ---\nVIDEO_CHECK_INTERVAL_MINUTES = 5  # How often to check for new YouTube videos\nREMINDER_CHECK_INTERVAL_MINUTES = 1 # How often to check for due reminders\nPREMIUM_EXPIRY_CHECK_INTERVAL_HOURS = 1 # How often to check for expired premium accounts\nYT_API_CALL_DELAY_SECONDS = 1 # Small delay between individual YouTube API calls in loops\n\n# --- Logging Configuration ---\nLOG_LEVEL = \"INFO\" # DEBUG, INFO, WARNING, ERROR, CRITICAL\n\n# ==============================================================================\n# IMPORTS\n# ==============================================================================\nimport logging\nimport sqlite3\nfrom datetime import datetime, timedelta, timezone\nimport re\nimport json\nimport time\nimport uuid # For unique referral codes\nfrom functools import wraps\n\n# Third-party libraries\nimport gspread\nfrom oauth2client.service_account import ServiceAccountCredentials\nimport requests # Generally useful, though PTB handles most HTTP for Telegram\nimport razorpay\n\nfrom telegram import (\n    Update, InlineKeyboardButton, InlineKeyboardMarkup, ParseMode, ChatMember, BotCommand\n)\nfrom telegram.ext import (\n    Updater, CommandHandler, MessageHandler, Filters, CallbackContext,\n    CallbackQueryHandler, ConversationHandler, JobQueue\n)\nfrom telegram.error import TelegramError, BadRequest, ChatMigrated, NetworkError, Unauthorized, TimedOut\n\nfrom googleapiclient.discovery import build\nfrom googleapiclient.errors import HttpError as GoogleApiHttpError\n\n# ==============================================================================\n# LOGGING SETUP\n# ==============================================================================\nlogging.basicConfig(\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    level=getattr(logging, LOG_LEVEL.upper(), logging.INFO)\n)\nlogger = logging.getLogger(__name__)\n\n# ==============================================================================\n# APPLICATION CONSTANTS\n# ==============================================================================\n# User Tiers & Limits\nFREE_TIER_YT_CHANNELS = 3\nFREE_TIER_TG_GROUPS_PER_YT_CHANNEL = 1 # Max Telegram groups per YouTube channel for free users\nFREE_TIER_TOTAL_TG_GROUPS = 3 # Max total Telegram groups a free user can link\n\nPREMIUM_PLAN_1_ID = \"plan_premium_1_monthly\"\nPREMIUM_PLAN_1_NAME = \"Pro Monthly\"\nPREMIUM_PLAN_1_PRICE = 11900  # In paisa (e.g., ₹119.00)\nPREMIUM_PLAN_1_DURATION_MONTHS = 1\nPREMIUM_PLAN_1_YT_CHANNELS = 10\nPREMIUM_PLAN_1_TG_GROUPS_PER_YT_CHANNEL = 5\nPREMIUM_PLAN_1_TOTAL_TG_GROUPS = 25\n\nPREMIUM_PLAN_2_ID = \"plan_premium_3_quarterly\"\nPREMIUM_PLAN_2_NAME = \"Pro Quarterly\"\nPREMIUM_PLAN_2_PRICE = 29900  # In paisa (e.g., ₹299.00)\nPREMIUM_PLAN_2_DURATION_MONTHS = 3\nPREMIUM_PLAN_2_YT_CHANNELS = 10 # Same channel count, better price\nPREMIUM_PLAN_2_TG_GROUPS_PER_YT_CHANNEL = 5\nPREMIUM_PLAN_2_TOTAL_TG_GROUPS = 25\n\n# Referral Program\nREFERRAL_PREMIUM_DURATION_MONTHS = 3\nREFERRAL_TARGET_COUNT = 3 # Number of referred users who need to go premium\n\n# Callback Data Prefixes (ensure they are distinct and descriptive)\nCB_MAIN_MENU = \"cb_main\"\nCB_MY_CHANNELS = \"cb_my_ch\"\nCB_VIEW_CHANNEL_DETAIL_PREFIX = \"cb_ch_detail_\" # + user_subscription_id\nCB_MANAGE_CHANNEL_GROUPS_PREFIX = \"cb_ch_groups_\" # + user_subscription_id\nCB_ADD_GROUP_TO_CHANNEL_PREFIX = \"cb_ch_addgrp_\" # + user_subscription_id (starts convo)\nCB_UNLINK_TG_GROUP_PREFIX = \"cb_ch_unlinkgrp_\" # + channel_group_mapping_id\nCB_CONFIRM_DELETE_YT_CHANNEL_PREFIX = \"cb_ch_delconf_\" # + user_subscription_id\nCB_DO_DELETE_YT_CHANNEL_PREFIX = \"cb_ch_deldo_\" # + user_subscription_id\n\nCB_SCHEDULE_REMINDER = \"cb_sched_rem\" # Starts reminder convo\nCB_UPGRADE_OPTIONS = \"cb_upgrade_opts\"\nCB_PROCESS_UPGRADE_PLAN_1 = \"cb_proc_upg_p1\"\nCB_PROCESS_UPGRADE_PLAN_2 = \"cb_proc_upg_p2m\"\nCB_MY_REFERRAL_INFO = \"cb_my_ref_info\"\nCB_HELP_INFO = \"cb_help_info\"\n\nCB_ADMIN_PANEL = \"cb_adm_panel\"\nCB_ADMIN_VIEW_USERS = \"cb_adm_vu\"\nCB_ADMIN_VIEW_CONNECTIONS = \"cb_adm_vc\"\nCB_ADMIN_MANUAL_UPGRADE_START = \"cb_adm_upg_s\" # Starts convo\nCB_ADMIN_MANUAL_DOWNGRADE_START = \"cb_adm_dng_s\" # Starts convo\nCB_ADMIN_BROADCAST_START = \"cb_adm_bcast_s\" # Starts convo\n\nCB_CANCEL_CONVERSATION = \"cb_cancel_convo\"\n\n# Conversation States (using integers for simplicity)\n(ASK_YT_URL, ASK_TG_CHAT_ID_FOR_ADDCHANNEL) = range(2)\n(ASK_REMINDER_VIDEO_URL, ASK_REMINDER_DURATION_MINUTES) = range(2)\n(ASK_ADMIN_UPGRADE_USER_ID, ASK_ADMIN_UPGRADE_MONTHS) = range(2)\n(ASK_ADMIN_DOWNGRADE_USER_ID) = range(1)\n(ASK_ADMIN_BROADCAST_MESSAGE) = range(1)\n(ASK_TG_CHAT_ID_FOR_LINKING) = range(1) # For linking group to existing YT via menu\n\n# Bot commands to set for Telegram's UI\nBOT_COMMANDS = [\n    BotCommand(\"start\", \"Start the bot and see main menu\"),\n    BotCommand(\"help\", \"Get help and command list\"),\n    BotCommand(\"addchannel\", \"Link a YouTube channel to a Telegram chat\"),\n    BotCommand(\"mychannels\", \"View and manage your linked YouTube channels\"),\n    BotCommand(\"setreminder\", \"Set a reminder for a YouTube video\"),\n    BotCommand(\"upgrade\", \"Upgrade to a Premium plan\"),\n    BotCommand(\"myreferral\", \"Get your referral code and info\"),\n    BotCommand(\"cancel\", \"Cancel current operation (if any)\")\n]\nADMIN_BOT_COMMANDS = BOT_COMMANDS + [\n    BotCommand(\"admin\", \"Access Admin Panel\"),\n    BotCommand(\"simpayment\", \"(Admin) Simulate a successful payment for a user\")\n]\n\n# ==============================================================================\n# GLOBAL SINGLETONS (Lazy Initialized)\n# ==============================================================================\n_gspread_client = None\n_youtube_service = None\n_razorpay_client = None\n\n# ==============================================================================\n# GOOGLE SHEETS UTILITIES\n# ==============================================================================\ndef _get_gspread_client(force_reinitialize=False):\n    global _gspread_client\n    if _gspread_client is None or force_reinitialize:\n        if not GSHEET_SERVICE_ACCOUNT_FILE or GSHEET_SERVICE_ACCOUNT_FILE == 'YOUR_SERVICE_ACCOUNT_JSON_PATH_IN_COLAB':\n            logger.warning(\"Google Sheets service account file path is not configured. Sheets features disabled.\")\n            _gspread_client = None # Ensure it's None if config is bad\n            return None\n        if not os.path.exists(GSHEET_SERVICE_ACCOUNT_FILE):\n            logger.error(f\"Google Sheets service account file not found at: {GSHEET_SERVICE_ACCOUNT_FILE}\")\n            _gspread_client = None\n            return None\n        try:\n            scope = ['https://spreadsheets.google.com/feeds', 'https://www.googleapis.com/auth/drive']\n            creds = ServiceAccountCredentials.from_json_keyfile_name(GSHEET_SERVICE_ACCOUNT_FILE, scope)\n            _gspread_client = gspread.authorize(creds)\n            logger.info(\"Google Sheets client initialized successfully.\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize Google Sheets client: {e}\")\n            _gspread_client = None\n    return _gspread_client\n\ndef _get_or_create_worksheet(spreadsheet_name, worksheet_name, headers=None):\n    client = _get_gspread_client()\n    if not client:\n        return None\n    try:\n        spreadsheet = client.open(spreadsheet_name)\n    except gspread.exceptions.SpreadsheetNotFound:\n        logger.info(f\"Spreadsheet '{spreadsheet_name}' not found, creating new one.\")\n        try:\n            spreadsheet = client.create(spreadsheet_name)\n            # Optional: Share the new spreadsheet if needed\n            # spreadsheet.share('your-email@example.com', perm_type='user', role='writer')\n        except Exception as e_create_ss:\n            logger.error(f\"Failed to create spreadsheet '{spreadsheet_name}': {e_create_ss}\")\n            return None\n    except Exception as e_open_ss:\n        logger.error(f\"Error opening spreadsheet '{spreadsheet_name}': {e_open_ss}\")\n        return None\n\n    try:\n        worksheet = spreadsheet.worksheet(worksheet_name)\n    except gspread.exceptions.WorksheetNotFound:\n        logger.info(f\"Worksheet '{worksheet_name}' not found in '{spreadsheet_name}', creating new one.\")\n        try:\n            worksheet = spreadsheet.add_worksheet(title=worksheet_name, rows=\"100\", cols=\"20\")\n            if headers and isinstance(headers, list):\n                worksheet.append_row(headers) # Add headers if worksheet is new and headers are provided\n        except Exception as e_create_ws:\n            logger.error(f\"Failed to create worksheet '{worksheet_name}': {e_create_ws}\")\n            return None\n    except Exception as e_open_ws:\n        logger.error(f\"Error opening worksheet '{worksheet_name}': {e_open_ws}\")\n        return None\n    return worksheet\n\ndef sync_premium_user_to_sheet(user_id, username, premium_expiry_date, plan_name, amount_paid_paisa, payment_id):\n    if not _get_gspread_client(): \n        logger.warning(\"GSpread client not available for sync_premium_user_to_sheet.\")\n        return\n    worksheet = _get_or_create_worksheet(\n        GSHEET_PREMIUM_USERS_FILE_NAME,\n        GSHEET_PREMIUM_USERS_WORKSHEET_NAME,\n        headers=[\"User ID\", \"Username\", \"Premium Expiry Date (UTC)\", \"Plan Name\", \"Amount Paid (INR)\", \"Payment ID\", \"Subscription Update Date (UTC)\"]\n    )\n    if not worksheet: return\n\n    try:\n        # Convert datetime to string for Sheets\n        expiry_str = premium_expiry_date.strftime('%Y-%m-%d %H:%M:%S') if premium_expiry_date else \"N/A\"\n        update_time_str = datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')\n        amount_inr = f\"{amount_paid_paisa/100:.2f}\"\n\n        row_data = [str(user_id), username or \"N/A\", expiry_str, plan_name, amount_inr, payment_id, update_time_str]\n        \n        cell = worksheet.find(str(user_id), in_column=1) # Find user by ID in the first column\n        if cell:\n            worksheet.update(f'A{cell.row}', [row_data]) # Update existing row (updates entire row)\n            logger.info(f\"Updated premium user {user_id} in Google Sheet.\")\n        else:\n            worksheet.append_row(row_data) # Add new row\n            logger.info(f\"Added premium user {user_id} to Google Sheet.\")\n    except gspread.exceptions.APIError as e_gspread_api:\n        logger.error(f\"Google Sheets API error syncing premium user {user_id}: {e_gspread_api}\")\n        if \"quota\" in str(e_gspread_api).lower():\n            logger.critical(\"Google Sheets API quota likely exceeded!\")\n        # Potentially re-initialize client if it's a auth issue (though less common with service accounts)\n        _get_gspread_client(force_reinitialize=True)\n    except Exception as e:\n        logger.error(f\"General error syncing premium user {user_id} to Google Sheet: {e}\")\n\ndef remove_or_mark_premium_user_from_sheet(user_id, mark_as_expired=True):\n    if not _get_gspread_client(): \n        logger.warning(\"GSpread client not available for remove_or_mark_premium_user_from_sheet.\")\n        return\n    worksheet = _get_or_create_worksheet(GSHEET_PREMIUM_USERS_FILE_NAME, GSHEET_PREMIUM_USERS_WORKSHEET_NAME)\n    if not worksheet: return\n\n    try:\n        cell = worksheet.find(str(user_id), in_column=1)\n        if cell:\n            if mark_as_expired:\n                # Assuming columns: User ID, Username, Expiry, Plan, Amount, PaymentID, UpdateDate\n                worksheet.update_cell(cell.row, 3, \"EXPIRED/CANCELLED\") # Update Expiry Date cell\n                worksheet.update_cell(cell.row, 7, datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')) # Update UpdateDate\n                logger.info(f\"Marked user {user_id} as EXPIRED/CANCELLED in premium Google Sheet.\")\n            else:\n                worksheet.delete_rows(cell.row) # Less common, usually mark as expired\n                logger.info(f\"Deleted user {user_id} from premium Google Sheet.\")\n        else:\n            logger.info(f\"User {user_id} not found in premium Google Sheet for removal/marking.\")\n    except gspread.exceptions.APIError as e_gspread_api:\n        logger.error(f\"Google Sheets API error for user {user_id} during removal/marking: {e_gspread_api}\")\n    except Exception as e:\n        logger.error(f\"General error removing/marking user {user_id} from premium Google Sheet: {e}\")\n\ndef log_referral_event_to_sheet(referrer_id, referred_id, referred_username, event_type, details=\"\"):\n    if not _get_gspread_client(): \n        logger.warning(\"GSpread client not available for log_referral_event_to_sheet.\")\n        return\n    worksheet = _get_or_create_worksheet(\n        GSHEET_PREMIUM_USERS_FILE_NAME, # Using the same spreadsheet, different worksheet\n        GSHEET_REFERRALS_WORKSHEET_NAME,\n        headers=[\"Timestamp (UTC)\", \"Referrer User ID\", \"Referred User ID\", \"Referred Username\", \"Event Type\", \"Details\"]\n    )\n    if not worksheet: return\n    try:\n        timestamp_str = datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')\n        worksheet.append_row([\n            timestamp_str,\n            str(referrer_id) if referrer_id else \"N/A\",\n            str(referred_id) if referred_id else \"N/A\",\n            referred_username or \"N/A\",\n            event_type,\n            details\n        ])\n        logger.info(f\"Logged referral event: Referrer {referrer_id}, Referred {referred_id}, Event: {event_type}\")\n    except gspread.exceptions.APIError as e_gspread_api:\n        logger.error(f\"Google Sheets API error logging referral event: {e_gspread_api}\")\n    except Exception as e:\n        logger.error(f\"General error logging referral event to Google Sheet: {e}\")\n\n# ==============================================================================\n# DATABASE UTILITIES\n# ==============================================================================\ndef get_db_connection():\n    conn = sqlite3.connect(DATABASE_NAME, detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)\n    conn.row_factory = sqlite3.Row # Access columns by name\n    conn.execute(\"PRAGMA foreign_keys = ON;\") # Enforce foreign key constraints\n    return conn\n\ndef initialize_db():\n    with get_db_connection() as conn: # `with` handles commit/rollback and close\n        cursor = conn.cursor()\n        # Users table\n        cursor.execute('''\n        CREATE TABLE IF NOT EXISTS users (\n            user_id INTEGER PRIMARY KEY,\n            username TEXT,\n            first_name TEXT,\n            last_name TEXT,\n            is_premium BOOLEAN DEFAULT FALSE,\n            premium_expiry_date TIMESTAMP, -- Stored as UTC\n            referral_code TEXT UNIQUE, -- Generated for each user\n            referred_by_user_id INTEGER, -- User ID of the one who referred this user\n            join_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP -- Stored as UTC\n        )\n        ''')\n        # YouTube Channels (globally unique by youtube_channel_id)\n        cursor.execute('''\n        CREATE TABLE IF NOT EXISTS youtube_channels (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            youtube_channel_id TEXT UNIQUE NOT NULL,\n            youtube_channel_name TEXT,\n            last_fetched_video_id TEXT, -- ID of the latest video processed by the bot for this channel\n            last_checked TIMESTAMP -- When the bot last polled this channel (UTC)\n        )\n        ''')\n        # User's subscription/link to a YouTube channel (Many-to-Many through this table)\n        cursor.execute('''\n        CREATE TABLE IF NOT EXISTS user_youtube_subscriptions (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            user_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,\n            yt_channel_db_id INTEGER NOT NULL REFERENCES youtube_channels(id) ON DELETE CASCADE,\n            date_linked TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- Stored as UTC\n            UNIQUE (user_id, yt_channel_db_id)\n        )\n        ''')\n        # Telegram Groups/Channels where videos from a specific user's subscription are posted\n        cursor.execute('''\n        CREATE TABLE IF NOT EXISTS channel_group_mappings (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            user_subscription_id INTEGER NOT NULL REFERENCES user_youtube_subscriptions(id) ON DELETE CASCADE,\n            telegram_chat_id INTEGER NOT NULL, -- Telegram Group or Channel ID (can be negative)\n            telegram_chat_title TEXT, -- Store for easier display\n            is_active BOOLEAN DEFAULT TRUE, -- To deactivate if bot is kicked, etc.\n            date_mapped TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- Stored as UTC\n            UNIQUE (user_subscription_id, telegram_chat_id)\n        )\n        ''')\n        # Reminders table\n        cursor.execute('''\n        CREATE TABLE IF NOT EXISTS reminders (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            user_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,\n            youtube_video_url TEXT NOT NULL,\n            video_title TEXT,\n            remind_at TIMESTAMP NOT NULL, -- Stored as UTC\n            is_sent BOOLEAN DEFAULT FALSE,\n            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP -- Stored as UTC\n        )\n        ''')\n        # Referrals tracking table\n        cursor.execute('''\n        CREATE TABLE IF NOT EXISTS referrals_progress (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            referrer_user_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,\n            referred_user_id INTEGER NOT NULL UNIQUE REFERENCES users(user_id) ON DELETE CASCADE, -- A user can only be successfully referred once\n            signup_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- When the referred user signed up using code (UTC)\n            became_premium_date TIMESTAMP, -- When the referred user upgraded to premium (UTC)\n            referrer_rewarded_date TIMESTAMP -- When the referrer was given their reward for this batch of referrals (UTC)\n        )\n        ''')\n        logger.info(\"Database initialized/checked successfully.\")\n\n# --- User Management Functions ---\ndef add_or_update_user(user_id, username, first_name, last_name, referred_by_code=None):\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        existing_user = get_user(user_id, conn_passed=conn)\n        referrer_user_id = None\n\n        if referred_by_code and not existing_user: # Process referral only for new users\n            cursor.execute(\"SELECT user_id FROM users WHERE referral_code = ? AND user_id != ?\", (referred_by_code, user_id))\n            referrer = cursor.fetchone()\n            if referrer:\n                referrer_user_id = referrer[\"user_id\"]\n                logger.info(f\"User {user_id} signing up, referred by {referrer_user_id} using code {referred_by_code}.\")\n                try:\n                    cursor.execute('''\n                        INSERT INTO referrals_progress (referrer_user_id, referred_user_id, signup_date)\n                        VALUES (?, ?, CURRENT_TIMESTAMP)\n                    ''', (referrer_user_id, user_id))\n                    log_referral_event_to_sheet(referrer_user_id, user_id, username, \"REFERRED_USER_SIGNUP\", f\"Code: {referred_by_code}\")\n                except sqlite3.IntegrityError: # Should be rare due to UNIQUE on referred_user_id\n                    logger.warning(f\"User {user_id} might have already been recorded in referrals_progress.\")\n\n        # Prepare user data for insert/update\n        user_data = {\n            'user_id': user_id,\n            'username': username,\n            'first_name': first_name,\n            'last_name': last_name,\n            'join_date': datetime.now(timezone.utc) # Always update join_date on new, or keep old on update\n        }\n\n        if existing_user:\n            # Update existing user, but don't overwrite referral_code or referred_by_user_id if they already exist\n            cursor.execute('''\n            UPDATE users SET username=:username, first_name=:first_name, last_name=:last_name\n            WHERE user_id=:user_id\n            ''', user_data)\n            logger.debug(f\"Updated existing user: {user_id}\")\n        else:\n            # New user\n            user_data['referral_code'] = str(uuid.uuid4())[:10].upper() # Generate a new referral code\n            user_data['referred_by_user_id'] = referrer_user_id\n            cursor.execute('''\n            INSERT INTO users (user_id, username, first_name, last_name, referral_code, referred_by_user_id, join_date)\n            VALUES (:user_id, :username, :first_name, :last_name, :referral_code, :referred_by_user_id, :join_date)\n            ''', user_data)\n            logger.info(f\"Added new user: {user_id}, Referral code: {user_data['referral_code']}\")\n\ndef get_user(user_id, conn_passed=None):\n    conn = conn_passed or get_db_connection()\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT * FROM users WHERE user_id = ?\", (user_id,))\n    user = cursor.fetchone()\n    if not conn_passed: conn.close()\n    return user # Returns a Row object or None\n\ndef set_user_premium_status(user_id, plan_id, plan_name, duration_months, amount_paid_paisa, payment_id=\"MANUAL_ADMIN\"):\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        user = get_user(user_id, conn_passed=conn)\n        if not user:\n            logger.error(f\"Attempted to upgrade non-existent user {user_id}\")\n            return False, \"User not found.\"\n\n        current_expiry_utc = user['premium_expiry_date'] # This should be UTC if stored correctly\n        start_date_utc = datetime.now(timezone.utc)\n        if current_expiry_utc and current_expiry_utc > start_date_utc:\n            start_date_utc = current_expiry_utc # Stack premium duration\n\n        # Approximate month duration, can be more precise if needed\n        new_expiry_date_utc = start_date_utc + timedelta(days=duration_months * 30.4375)\n\n        try:\n            cursor.execute('''\n            UPDATE users SET is_premium = TRUE, premium_expiry_date = ?\n            WHERE user_id = ?\n            ''', (new_expiry_date_utc, user_id))\n            logger.info(f\"User {user_id} upgraded to premium. Plan: {plan_name}. New Expiry (UTC): {new_expiry_date_utc}. Payment ID: {payment_id}\")\n\n            sync_premium_user_to_sheet(user_id, user['username'], new_expiry_date_utc, plan_name, amount_paid_paisa, payment_id)\n\n            # --- Referral Fulfillment --- \n            if user['referred_by_user_id']:\n                # Check if this referred user's upgrade should trigger a reward\n                cursor.execute('''\n                    UPDATE referrals_progress\n                    SET became_premium_date = CURRENT_TIMESTAMP\n                    WHERE referred_user_id = ? AND referrer_rewarded_date IS NULL AND became_premium_date IS NULL\n                ''', (user_id,))\n                if cursor.rowcount > 0:\n                    logger.info(f\"User {user_id} (referred by {user['referred_by_user_id']}) became premium. Updated referral progress.\")\n                    log_referral_event_to_sheet(user['referred_by_user_id'], user_id, user['username'], \"REFERRED_USER_BECAME_PREMIUM\", f\"Plan: {plan_name}\")\n                    # Now check if the referrer qualifies for a reward\n                    check_and_grant_referral_reward(user['referred_by_user_id'], conn_passed=conn)\n            return True, f\"Successfully upgraded to {plan_name}. Your premium access is active until {new_expiry_date_utc.strftime('%Y-%m-%d %H:%M')} UTC.\"\n        except Exception as e:\n            logger.error(f\"Error during database update for user {user_id} premium status: {e}\")\n            return False, \"Database error during upgrade.\"\n\ndef check_and_grant_referral_reward(referrer_user_id, conn_passed=None):\n    # This function MUST be called within an existing transaction (conn_passed should be provided)\n    # to ensure atomicity of checking referrals and granting rewards.\n    conn = conn_passed\n    if not conn:\n        logger.error(\"check_and_grant_referral_reward called without a passed DB connection. This is unsafe.\")\n        return False # Or raise an error\n    \n    cursor = conn.cursor()\n    # Count successful, unrewarded premium referrals for this referrer\n    cursor.execute('''\n        SELECT id FROM referrals_progress\n        WHERE referrer_user_id = ? AND became_premium_date IS NOT NULL AND referrer_rewarded_date IS NULL\n    ''', (referrer_user_id,))\n    qualifying_referrals = cursor.fetchall()\n\n    if len(qualifying_referrals) >= REFERRAL_TARGET_COUNT:\n        logger.info(f\"Referrer {referrer_user_id} has {len(qualifying_referrals)} qualifying premium referrals. Awarding premium reward.\")\n        \n        # Grant premium to referrer (this calls set_user_premium_status, which opens its own transaction)\n        # For true atomicity, this logic should be more integrated or set_user_premium_status should accept conn.\n        # For now, we proceed, but be aware of nested transactions if set_user_premium_status also uses 'with'.\n        # A simple fix: set_user_premium_status should also accept conn_passed.\n        # As set_user_premium_status is complex, for now, we'll call it and it will manage its own transaction.\n        # This means the reward grant isn't strictly in the *same* transaction as marking referrals.\n\n        # For this simplified version, we call the existing set_user_premium_status directly.\n        # In a more robust system, this would be part of a larger service layer transaction.\n        reward_plan_name = f\"Referral Reward ({REFERRAL_PREMIUM_DURATION_MONTHS} months)\"\n        success, _ = set_user_premium_status(referrer_user_id, \"REFERRAL_REWARD\", reward_plan_name, REFERRAL_PREMIUM_DURATION_MONTHS, 0, f\"REFERRED_{REFERRAL_TARGET_COUNT}_USERS\")\n\n        if success:\n            # Mark these specific N referrals as rewarded for this referrer\n            # Get the IDs of the first N qualifying referrals to mark them\n            ids_to_mark_rewarded = [ref['id'] for ref in qualifying_referrals[:REFERRAL_TARGET_COUNT]]\n            placeholders = ','.join('?' for _ in ids_to_mark_rewarded)\n            cursor.execute(f'''\n                UPDATE referrals_progress\n                SET referrer_rewarded_date = CURRENT_TIMESTAMP\n                WHERE id IN ({placeholders})\n            ''', ids_to_mark_rewarded)\n            logger.info(f\"Marked {len(ids_to_mark_rewarded)} referrals as rewarded for referrer {referrer_user_id}.\")\n            log_referral_event_to_sheet(referrer_user_id, None, None, \"REFERRER_REWARDED_PREMIUM\", f\"{REFERRAL_PREMIUM_DURATION_MONTHS} months for referring {REFERRAL_TARGET_COUNT} users.\")\n            # Notify referrer (implement send_telegram_message_to_user(user_id, message) if not already done)\n            # This notification should be done by the calling context (e.g., the bot handler)\n            return True # Indicates reward was processed\n        else:\n            logger.error(f\"Failed to grant referral reward premium to user {referrer_user_id}.\")\n    return False # No reward granted or an error occurred\n\ndef get_user_tier_limits(user_id):\n    user = get_user(user_id)\n    is_currently_premium = False\n    if user and user['is_premium'] and user['premium_expiry_date']:\n        if isinstance(user['premium_expiry_date'], str):\ # Datetime might be string from DB if not parsed\n            try: user_premium_expiry_date = datetime.fromisoformat(user['premium_expiry_date'])\n            except ValueError: user_premium_expiry_date = datetime.strptime(user['premium_expiry_date'], '%Y-%m-%d %H:%M:%S.%f%z') # Try another common format\n        else: user_premium_expiry_date = user['premium_expiry_date']\n        \n        if user_premium_expiry_date > datetime.now(timezone.utc):\n            is_currently_premium = True\n\n    if is_currently_premium:\n        return {\n            'max_yt_channels': PREMIUM_PLAN_1_YT_CHANNELS, # Assuming same for all premium plans for now\n            'max_tg_groups_per_yt': PREMIUM_PLAN_1_TG_GROUPS_PER_YT_CHANNEL,\n            'max_total_tg_groups': PREMIUM_PLAN_1_TOTAL_TG_GROUPS,\n            'is_premium': True,\n            'name': 'Premium'\n        }\n    else:\n        # If premium has expired but DB not updated by job yet, ensure user is considered free here\n        if user and user['is_premium']: # DB says premium, but expiry check here says no\n            with get_db_connection() as conn:\n                cursor = conn.cursor()\n                cursor.execute(\"UPDATE users SET is_premium = FALSE, premium_expiry_date = NULL WHERE user_id = ?\", (user_id,))\n            logger.info(f\"Detected expired premium for user {user_id} during limit check; updated status to free.\")\n            remove_or_mark_premium_user_from_sheet(user_id, mark_as_expired=True)\n\n        return {\n            'max_yt_channels': FREE_TIER_YT_CHANNELS,\n            'max_tg_groups_per_yt': FREE_TIER_TG_GROUPS_PER_YT_CHANNEL,\n            'max_total_tg_groups': FREE_TIER_TOTAL_TG_GROUPS,\n            'is_premium': False,\n            'name': 'Free'\n        }\n\n# --- YouTube Channel & Mapping DB Functions ---\ndef add_or_get_yt_channel_in_db(yt_channel_api_id, yt_channel_name):\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT id, youtube_channel_name FROM youtube_channels WHERE youtube_channel_id = ?\", (yt_channel_api_id,))\n        channel = cursor.fetchone()\n        if channel:\n            if channel['youtube_channel_name'] != yt_channel_name: # Update name if changed\n                cursor.execute(\"UPDATE youtube_channels SET youtube_channel_name = ? WHERE id = ?\", (yt_channel_name, channel['id']))\n            return channel['id']\n        else:\n            cursor.execute(\"INSERT INTO youtube_channels (youtube_channel_id, youtube_channel_name, last_checked) VALUES (?, ?, ?)\", \n                           (yt_channel_api_id, yt_channel_name, datetime.now(timezone.utc)))\n            return cursor.lastrowid\n\ndef add_user_subscription_to_yt_channel(user_id, yt_channel_db_id):\n    with get_db_connection() as conn:\n        try:\n            cursor = conn.cursor()\n            cursor.execute(\"INSERT INTO user_youtube_subscriptions (user_id, yt_channel_db_id, date_linked) VALUES (?, ?, CURRENT_TIMESTAMP)\", \n                           (user_id, yt_channel_db_id))\n            return cursor.lastrowid # Returns the ID of the new user_youtube_subscriptions row\n        except sqlite3.IntegrityError: # (user_id, yt_channel_db_id) is UNIQUE\n            logger.warning(f\"User {user_id} already subscribed to YT channel DB ID {yt_channel_db_id}. Fetching existing subscription.\")\n            cursor.execute(\"SELECT id FROM user_youtube_subscriptions WHERE user_id = ? AND yt_channel_db_id = ?\", (user_id, yt_channel_db_id))\n            existing_sub = cursor.fetchone()\n            return existing_sub['id'] if existing_sub else None # Should always find one if IntegrityError\n\ndef link_subscription_to_tg_chat(user_subscription_id, tg_chat_id, tg_chat_title):\n    with get_db_connection() as conn:\n        try:\n            cursor = conn.cursor()\n            cursor.execute('''INSERT INTO channel_group_mappings \n                              (user_subscription_id, telegram_chat_id, telegram_chat_title, date_mapped)\n                              VALUES (?, ?, ?, CURRENT_TIMESTAMP)''', \n                           (user_subscription_id, tg_chat_id, tg_chat_title))\n            return cursor.lastrowid # ID of the new mapping\n        except sqlite3.IntegrityError: # (user_subscription_id, telegram_chat_id) is UNIQUE\n            logger.warning(f\"Subscription ID {user_subscription_id} is already linked to TG chat ID {tg_chat_id}.\")\n            # Optionally, reactivate if it was inactive\n            cursor.execute(\"UPDATE channel_group_mappings SET is_active = TRUE WHERE user_subscription_id = ? AND telegram_chat_id = ?\",\n                           (user_subscription_id, tg_chat_id))\n            cursor.execute(\"SELECT id FROM channel_group_mappings WHERE user_subscription_id = ? AND telegram_chat_id = ?\",\n                           (user_subscription_id, tg_chat_id))\n            existing_mapping = cursor.fetchone()\n            return existing_mapping['id'] if existing_mapping else None\n\ndef get_user_subscribed_yt_channels_details(user_id):\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        cursor.execute('''\n            SELECT\n                uys.id as user_subscription_id,\n                yc.youtube_channel_id as yt_api_id,\n                yc.youtube_channel_name,\n                (SELECT COUNT(cgm.id) FROM channel_group_mappings cgm WHERE cgm.user_subscription_id = uys.id AND cgm.is_active = TRUE) as active_tg_links\n            FROM user_youtube_subscriptions uys\n            JOIN youtube_channels yc ON uys.yt_channel_db_id = yc.id\n            WHERE uys.user_id = ?\n            ORDER BY yc.youtube_channel_name\n        ''', (user_id,))\n        return [dict(row) for row in cursor.fetchall()]\n\ndef get_linked_tg_chats_for_subscription(user_subscription_id):\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        cursor.execute('''\n            SELECT id as mapping_id, telegram_chat_id, telegram_chat_title\n            FROM channel_group_mappings\n            WHERE user_subscription_id = ? AND is_active = TRUE\n            ORDER BY telegram_chat_title\n        ''', (user_subscription_id,))\n        return [dict(row) for row in cursor.fetchall()]\n\ndef count_user_linked_yt_channels(user_id):\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT COUNT(id) as count FROM user_youtube_subscriptions WHERE user_id = ?\", (user_id,))\n        return cursor.fetchone()['count']\n\ndef count_user_total_active_tg_group_links(user_id):\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        cursor.execute('''\n            SELECT COUNT(cgm.id) as count\n            FROM channel_group_mappings cgm\n            JOIN user_youtube_subscriptions uys ON cgm.user_subscription_id = uys.id\n            WHERE uys.user_id = ? AND cgm.is_active = TRUE\n        ''', (user_id,))\n        return cursor.fetchone()['count']\n\ndef count_tg_links_for_specific_yt_subscription(user_subscription_id):\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT COUNT(id) as count FROM channel_group_mappings WHERE user_subscription_id = ? AND is_active = TRUE\", (user_subscription_id,))\n        return cursor.fetchone()['count']\n\ndef delete_user_yt_channel_subscription(user_subscription_id):\n    # This will also delete related channel_group_mappings due to ON DELETE CASCADE\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        cursor.execute(\"DELETE FROM user_youtube_subscriptions WHERE id = ?\", (user_subscription_id,))\n        return cursor.rowcount > 0 # True if a row was deleted\n\ndef unlink_tg_chat_from_subscription(channel_group_mapping_id):\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        # Consider soft delete (is_active=FALSE) vs hard delete\n        cursor.execute(\"DELETE FROM channel_group_mappings WHERE id = ?\", (channel_group_mapping_id,))\n        return cursor.rowcount > 0\n\ndef deactivate_tg_chat_mapping(mapping_id_or_sub_id_and_chat_id, by_mapping_id=True, user_subscription_id=None, telegram_chat_id=None):\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        if by_mapping_id:\n            cursor.execute(\"UPDATE channel_group_mappings SET is_active = FALSE WHERE id = ?\", (mapping_id_or_sub_id_and_chat_id,))\n        elif user_subscription_id and telegram_chat_id:\n             cursor.execute(\"UPDATE channel_group_mappings SET is_active = FALSE WHERE user_subscription_id = ? AND telegram_chat_id = ?\", \n                            (user_subscription_id, telegram_chat_id))\n        else:\n            return False # Insufficient parameters\n        return cursor.rowcount > 0\n\n# --- Reminder DB Functions ---\ndef add_reminder_to_db(user_id, video_url, video_title, remind_at_utc):\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        cursor.execute('''\n        INSERT INTO reminders (user_id, youtube_video_url, video_title, remind_at, created_at)\n        VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)\n        ''', (user_id, video_url, video_title, remind_at_utc))\n        return cursor.lastrowid\n\ndef get_due_reminders_from_db():\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        now_utc = datetime.now(timezone.utc)\n        cursor.execute('''\n        SELECT id, user_id, youtube_video_url, video_title, remind_at FROM reminders\n        WHERE is_sent = FALSE AND remind_at <= ?\n        ORDER BY remind_at\n        ''', (now_utc,))\n        return [dict(r) for r in cursor.fetchall()]\n\ndef mark_reminder_as_sent_in_db(reminder_id):\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        cursor.execute(\"UPDATE reminders SET is_sent = TRUE WHERE id = ?\", (reminder_id,))\n        return cursor.rowcount > 0\n\n# --- Admin Data Fetching ---\ndef get_all_users_for_admin():\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        # Ensure premium_expiry_date is fetched for proper display\n        cursor.execute(\"SELECT user_id, username, first_name, is_premium, premium_expiry_date, join_date FROM users ORDER BY join_date DESC\")\n        return [dict(u) for u in cursor.fetchall()]\n\ndef get_all_active_connections_for_admin():\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        cursor.execute('''\n            SELECT\n                u.user_id, u.username AS user_username,\n                yc.youtube_channel_name, yc.youtube_channel_id AS yt_api_id,\n                cgm.telegram_chat_id, cgm.telegram_chat_title,\n                uys.date_linked, cgm.date_mapped\n            FROM users u\n            JOIN user_youtube_subscriptions uys ON u.user_id = uys.user_id\n            JOIN youtube_channels yc ON uys.yt_channel_db_id = yc.id\n            JOIN channel_group_mappings cgm ON uys.id = cgm.user_subscription_id\n            WHERE cgm.is_active = TRUE\n            ORDER BY u.user_id, yc.youtube_channel_name, cgm.telegram_chat_title\n        ''')\n        return [dict(c) for c in cursor.fetchall()]\n\n\n# ==============================================================================\n# YOUTUBE API UTILITIES\n# ==============================================================================\ndef get_youtube_service(force_reinitialize=False):\n    global _youtube_service\n    if _youtube_service is None or force_reinitialize:\n        if not YOUTUBE_API_KEY or YOUTUBE_API_KEY == \"YOUR_YOUTUBE_API_KEY_HERE\":\n            logger.error(\"YouTube API Key is not configured. YouTube features will be disabled.\")\n            _youtube_service = None\n            return None\n        try:\n            _youtube_service = build('youtube', 'v3', developerKey=YOUTUBE_API_KEY, cache_discovery=False)\n            logger.info(\"YouTube service client initialized successfully.\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize YouTube service client: {e}\")\n            _youtube_service = None\n    return _youtube_service\n\ndef extract_yt_channel_id_from_url(url_input):\n    # Try to extract UCxxxx ID first (most reliable)\n    uc_match = re.search(r'(?:youtube\\.com|youtu\\.be)/channel/(UC[a-zA-Z0-9_-]{22})', url_input)\n    if uc_match:\n        return uc_match.group(1), None\n\n    # Try to extract from @handle or /c/custom_url or /user/legacy_username\n    # These require an API call to resolve to UCxxxx ID\n    generic_match = re.search(r'(?:youtube\\.com|youtu\\.be)/(?:c/|user/|@)?([^/?&\\s]+)', url_input)\n    if not generic_match:\n        # Could be a video URL, try to get channel ID from video\n        video_id_match = re.search(r\"(?:youtube\\.com/(?:watch\\?v=|embed/|shorts/)|youtu\\.be/)([a-zA-Z0-9_-]{11})\", url_input)\n        if video_id_match:\n            video_id = video_id_match.group(1)\n            video_details, err = get_yt_video_details(video_id)\n            if video_details and video_details.get('channel_id'):\n                logger.info(f\"Extracted channel ID {video_details['channel_id']} from video URL {url_input}\")\n                return video_details['channel_id'], None\n            else:\n                return None, f\"Could not get channel ID from video URL. Error: {err or 'Unknown'}\"\n        return None, \"Invalid YouTube URL format. Please use a channel URL (e.g., /channel/UCxxx, /@handle) or a video URL.\"\n\n    identifier = generic_match.group(1)\n    youtube = get_youtube_service()\n    if not youtube: return None, \"YouTube API service unavailable for resolving channel ID.\"\n\n    try:\n        # Try resolving @handle first if API supports `forHandle` (check YouTube API docs for current best practice)\n        # As of my last update, direct `forHandle` in channels.list was experimental or not widely available.\n        # The most common way is to use search for the handle.\n        if identifier.startswith('@'):\n            search_query = identifier # Search for \"@handle\"\n        else:\n            search_query = identifier # Search for custom URL name or legacy username\n\n        search_response = youtube.search().list(\n            q=search_query,\n            part=\"snippet\",\n            type=\"channel\",\n            maxResults=1\n        ).execute()\n\n        if search_response.get(\"items\"):\n            resolved_channel_id = search_response[\"items\"][0][\"snippet\"][\"channelId\"]\n            logger.info(f\"Resolved identifier '{identifier}' to channel ID '{resolved_channel_id}' via search.\")\n            return resolved_channel_id, None\n        else:\n            # If search fails, it's possible the identifier itself IS a channel ID (e.g. legacy username was the channel ID)\n            # Or for old /user/ links where API doesn't resolve via search easily.\n            # Let's try one more channels().list with the identifier as an ID parameter.\n            try:\n                channel_response = youtube.channels().list(part='id', id=identifier).execute()\n                if channel_response.get('items'):\n                    logger.info(f\"Identifier '{identifier}' appears to be a direct channel ID.\")\n                    return channel_response['items'][0]['id'], None\n            except GoogleApiHttpError as e_direct:\n                if e_direct.resp.status == 400: # Bad request, likely not a valid ID format\n                    logger.warning(f\"Identifier '{identifier}' is not a direct channel ID and search failed.\")\n                else: raise e_direct # Re-raise other API errors\n            return None, f\"Could not resolve '{identifier}' to a YouTube Channel ID. Please use a direct /channel/UC... link if possible.\"\n\n    except GoogleApiHttpError as e_api:\n        logger.error(f\"YouTube API error resolving channel ID for '{identifier}': {e_api}\")\n        error_details = e_api.content.decode() if e_api.content else str(e_api)\n        if \"quotaExceeded\" in error_details:\n            return None, \"YouTube API quota exceeded. Please try again later.\"\n        return None, f\"YouTube API error: {error_details[:200]}\"\n    except Exception as e_general:\n        logger.error(f\"General error resolving channel ID for '{identifier}': {e_general}\")\n        return None, f\"An unexpected error occurred: {str(e_general)[:200]}\"\n\ndef get_yt_channel_details(channel_api_id):\n    youtube = get_youtube_service()\n    if not youtube: return None, \"YouTube API service unavailable.\"\n    try:\n        request = youtube.channels().list(\n            part=\"snippet,contentDetails,statistics\",\n            id=channel_api_id\n        )\n        response = request.execute()\n        if response.get(\"items\"):\n            return response[\"items\"][0], None\n        return None, \"YouTube channel not found or no items returned by API.\"\n    except GoogleApiHttpError as e_api:\n        logger.error(f\"YouTube API error fetching details for channel {channel_api_id}: {e_api}\")\n        error_details = e_api.content.decode() if e_api.content else str(e_api)\n        if \"quotaExceeded\" in error_details: return None, \"YouTube API quota exceeded.\"\n        return None, f\"YouTube API error: {error_details[:200]}\"\n    except Exception as e_general:\n        logger.error(f\"General error fetching details for channel {channel_api_id}: {e_general}\")\n        return None, f\"Unexpected error: {str(e_general)[:200]}\"\n\ndef get_latest_videos_from_yt_channel(channel_api_id, count=5):\n    youtube = get_youtube_service()\n    if not youtube: return [], \"YouTube API service unavailable.\"\n    try:\n        channel_info, error = get_yt_channel_details(channel_api_id)\n        if error or not channel_info:\n            return [], error or \"Could not get channel info to find uploads playlist.\"\n\n        uploads_playlist_id = channel_info[\"contentDetails\"][\"relatedPlaylists\"][\"uploads\"]\n        if not uploads_playlist_id:\n             return [], \"Could not find uploads playlist ID for the channel.\"\n\n        playlist_items_response = youtube.playlistItems().list(\n            part=\"snippet,contentDetails\",\n            playlistId=uploads_playlist_id,\n            maxResults=count\n        ).execute()\n\n        videos = []\n        for item in playlist_items_response.get(\"items\", []):\n            if item[\"snippet\"][\"resourceId\"][\"kind\"] == \"youtube#video\":\n                video_data = {\n                    \"id\": item[\"snippet\"][\"resourceId\"][\"videoId\"],\n                    \"title\": item[\"snippet\"][\"title\"],\n                    \"published_at_iso\": item[\"contentDetails\"][\"videoPublishedAt\"], # ISO 8601 (UTC)\n                    \"description\": item[\"snippet\"][\"description\"],\n                    \"thumbnail_url\": item[\"snippet\"][\"thumbnails\"].get(\"default\", {}).get(\"url\")\n                }\n                videos.append(video_data)\n        return videos, None # Videos are newest first by default from playlistItems\n\n    except GoogleApiHttpError as e_api:\n        logger.error(f\"YouTube API error fetching latest videos for channel {channel_api_id}: {e_api}\")\n        error_details = e_api.content.decode() if e_api.content else str(e_api)\n        if \"quotaExceeded\" in error_details: return [], \"YouTube API quota exceeded.\"\n        return [], f\"YouTube API error: {error_details[:200]}\"\n    except Exception as e_general:\n        logger.error(f\"General error fetching latest videos for channel {channel_api_id}: {e_general}\")\n        return [], f\"Unexpected error: {str(e_general)[:200]}\"\n\ndef get_yt_video_details(video_id):\n    youtube = get_youtube_service()\n    if not youtube: return None, \"YouTube API service unavailable.\"\n    try:\n        request = youtube.videos().list(\n            part=\"snippet,contentDetails\", # Add statistics if needed\n            id=video_id\n        )\n        response = request.execute()\n        if response.get(\"items\"):\n            item = response[\"items\"][0]\n            return {\n                \"id\": item[\"id\"],\n                \"title\": item[\"snippet\"][\"title\"],\n                \"description\": item[\"snippet\"][\"description\"],\n                \"channel_id\": item[\"snippet\"][\"channelId\"],\n                \"channel_title\": item[\"snippet\"][\"channelTitle\"],\n                \"published_at_iso\": item[\"snippet\"][\"publishedAt\"],\n                \"duration\": item[\"contentDetails\"].get(\"duration\") # PT_format (e.g. PT1M3S)\n            }, None\n        return None, \"Video not found by API.\"\n    except GoogleApiHttpError as e_api:\n        logger.error(f\"YouTube API error fetching details for video {video_id}: {e_api}\")\n        error_details = e_api.content.decode() if e_api.content else str(e_api)\n        if \"quotaExceeded\" in error_details: return None, \"YouTube API quota exceeded.\"\n        return None, f\"YouTube API error: {error_details[:200]}\"\n    except Exception as e_general:\n        logger.error(f\"General error fetching details for video {video_id}: {e_general}\")\n        return None, f\"Unexpected error: {str(e_general)[:200]}\"\n\n\n# ==============================================================================\n# PAYMENT UTILITIES (RAZORPAY - SIMULATED FOR COLAB)\n# ==============================================================================\ndef get_razorpay_client(force_reinitialize=False):\n    global _razorpay_client\n    if _razorpay_client is None or force_reinitialize:\n        if not RAZORPAY_KEY_ID or RAZORPAY_KEY_ID == \"YOUR_RAZORPAY_KEY_ID_HERE\" or \\\n           not RAZORPAY_KEY_SECRET or RAZORPAY_KEY_SECRET == \"YOUR_RAZORPAY_KEY_SECRET_HERE\":\n            logger.warning(\"Razorpay Key ID or Secret not configured. Real payment features disabled; using simulation.\")\n            _razorpay_client = None\n            return None\n        try:\n            _razorpay_client = razorpay.Client(auth=(RAZORPAY_KEY_ID, RAZORPAY_KEY_SECRET))\n            logger.info(\"Razorpay client initialized successfully.\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize Razorpay client: {e}\")\n            _razorpay_client = None\n    return _razorpay_client\n\ndef create_razorpay_order_for_plan(plan_id, plan_name, amount_paisa, user_id):\n    client = get_razorpay_client()\n    if not client:\n        # Simulate order creation for Colab if client not available but keys might be placeholder\n        mock_order_id = f\"order_mock_{plan_id}_{int(time.time())}\"\n        logger.info(f\"Mock Razorpay order created (simulation): {mock_order_id} for user {user_id}, plan {plan_name}, amount {amount_paisa/100} INR\")\n        return {'id': mock_order_id, 'amount': amount_paisa, 'currency': 'INR', 'status': 'created_mock'}, None\n\n    receipt_id = f\"user_{user_id}_plan_{plan_id}_{int(time.time())}\"\n    data = {\n        \"amount\": amount_paisa,\n        \"currency\": \"INR\",\n        \"receipt\": receipt_id,\n        \"payment_capture\": 1, # Auto capture payment\n        \"notes\": {\n            \"user_id\": str(user_id),\n            \"plan_id\": plan_id,\n            \"plan_name\": plan_name\n        }\n    }\n    try:\n        order = client.order.create(data=data)\n        logger.info(f\"Razorpay order created: {order['id']} for user {user_id}, plan {plan_name}, amount {amount_paisa/100} INR\")\n        return order, None\n    except razorpay.errors.BadRequestError as e_bad_req:\n        logger.error(f\"Razorpay BadRequestError creating order: {e_bad_req}\")\n        return None, f\"Payment gateway error (Bad Request): {e_bad_req.description if hasattr(e_bad_req, 'description') else str(e_bad_req)}\"\n    except Exception as e:\n        logger.error(f\"Razorpay order creation failed: {e}\")\n        return None, f\"Payment gateway error: {str(e)}\"\n\n# This function would be called by a webhook in a real app. For Colab, it's called by /simpayment or admin action.\ndef process_successful_payment(user_id, plan_id, plan_name, plan_duration_months, amount_paid_paisa, payment_id, order_id):\n    success, message = set_user_premium_status(user_id, plan_id, plan_name, plan_duration_months, amount_paid_paisa, payment_id)\n    if success:\n        logger.info(f\"Payment processed successfully for user {user_id}. Plan: {plan_name}. Order: {order_id}, Payment: {payment_id}\")\n        return True, message # Message from set_user_premium_status\n    else:\n        logger.error(f\"Failed to update user {user_id} premium status after payment. Order: {order_id}, Payment: {payment_id}. Reason: {message}\")\n        # IMPORTANT: In a real system, this needs robust handling (e.g., retry, manual admin alert)\n        # to ensure user gets their service after paying.\n        return False, f\"Payment received, but an internal error occurred while activating your plan: {message}. Please contact support with Payment ID: {payment_id}\"\n\n\n# ==============================================================================\n# INLINE KEYBOARDS\n# ==============================================================================\ndef main_menu_keyboard(user_id):\n    user_tier = get_user_tier_limits(user_id)\n    buttons = [\n        [InlineKeyboardButton(\"🔗 My YouTube Channels\", callback_data=CB_MY_CHANNELS)],\n        [InlineKeyboardButton(\"🗓️ Set Video Reminder\", callback_data=CB_SCHEDULE_REMINDER)],\n    ]\n    if not user_tier['is_premium']:\n        buttons.append([InlineKeyboardButton(\"🚀 Upgrade to Premium\", callback_data=CB_UPGRADE_OPTIONS)])\n    else:\n        buttons.append([InlineKeyboardButton(\"⭐ Premium Active\", callback_data=CB_UPGRADE_OPTIONS)]) # Link to manage/see status\n    \n    buttons.extend([\n        [InlineKeyboardButton(\"🤝 My Referral Code\", callback_data=CB_MY_REFERRAL_INFO)],\n        [InlineKeyboardButton(\"❓ Help & Commands\", callback_data=CB_HELP_INFO)],\n    ])\n\n    if user_id == ADMIN_TELEGRAM_ID:\n        buttons.append([InlineKeyboardButton(\"👑 Admin Panel\", callback_data=CB_ADMIN_PANEL)])\n    return InlineKeyboardMarkup(buttons)\n\ndef back_to_main_menu_button(text=\"🔙 Main Menu\"):\n    return InlineKeyboardButton(text, callback_data=CB_MAIN_MENU)\n\ndef cancel_conversation_button(text=\"❌ Cancel\"):\n    return InlineKeyboardButton(text, callback_data=CB_CANCEL_CONVERSATION)\n\ndef upgrade_options_page_keyboard(user_id):\n    user = get_user(user_id)\n    expiry_info = \"\"\n    if user and user['is_premium'] and user['premium_expiry_date']:\n        expiry_dt = user['premium_expiry_date']\n        if isinstance(expiry_dt, str): expiry_dt = datetime.fromisoformat(expiry_dt)\n        expiry_info = f\" (Active until: {expiry_dt.strftime('%Y-%m-%d %H:%M')} UTC)\"\n\n    keyboard = [\n        [InlineKeyboardButton(f\"{PREMIUM_PLAN_1_NAME}{expiry_info if PREMIUM_PLAN_1_DURATION_MONTHS==1 else ''} - ₹{PREMIUM_PLAN_1_PRICE/100:.2f}\", callback_data=CB_PROCESS_UPGRADE_PLAN_1)],\n        [InlineKeyboardButton(f\"{PREMIUM_PLAN_2_NAME}{expiry_info if PREMIUM_PLAN_2_DURATION_MONTHS==3 else ''} - ₹{PREMIUM_PLAN_2_PRICE/100:.2f}\", callback_data=CB_PROCESS_UPGRADE_PLAN_2)],\n        [back_to_main_menu_button()]\n    ]\n    return InlineKeyboardMarkup(keyboard)\n\ndef my_channels_page_keyboard(user_id):\n    channels = get_user_subscribed_yt_channels_details(user_id)\n    keyboard = []\n    if not channels:\n        keyboard.append([InlineKeyboardButton(\"No channels linked. Use /addchannel\", callback_data=\"noop_info\")]) # noop or info\n    for ch_data in channels:\n        label = f\"{ch_data['youtube_channel_name'][:30]}{'...' if len(ch_data['youtube_channel_name']) > 30 else ''} ({ch_data['active_tg_links']} TG links)\"\n        keyboard.append([InlineKeyboardButton(label, callback_data=f\"{CB_VIEW_CHANNEL_DETAIL_PREFIX}{ch_data['user_subscription_id']}\")])\n    keyboard.append([back_to_main_menu_button()])\n    return InlineKeyboardMarkup(keyboard)\n\ndef channel_detail_page_keyboard(user_subscription_id, yt_channel_name):\n    keyboard = [\n        [InlineKeyboardButton(f\"➕ Link to new TG Group/Channel\", callback_data=f\"{CB_ADD_GROUP_TO_CHANNEL_PREFIX}{user_subscription_id}\")],\n        [InlineKeyboardButton(f\"📋 Manage Linked TG Groups\", callback_data=f\"{CB_MANAGE_CHANNEL_GROUPS_PREFIX}{user_subscription_id}\")],\n        [InlineKeyboardButton(f\"🗑️ Unlink '{yt_channel_name[:20]}' from Bot\", callback_data=f\"{CB_CONFIRM_DELETE_YT_CHANNEL_PREFIX}{user_subscription_id}\")],\n        [InlineKeyboardButton(\"⬅️ Back to My Channels\", callback_data=CB_MY_CHANNELS)]\n    ]\n    return InlineKeyboardMarkup(keyboard)\n\ndef confirm_delete_yt_channel_keyboard(user_subscription_id, yt_channel_name):\n    keyboard = [\n        [InlineKeyboardButton(f\"✅ Yes, Unlink '{yt_channel_name[:20]}'!\", callback_data=f\"{CB_DO_DELETE_YT_CHANNEL_PREFIX}{user_subscription_id}\")],\n        [InlineKeyboardButton(\"❌ No, Keep It\", callback_data=f\"{CB_VIEW_CHANNEL_DETAIL_PREFIX}{user_subscription_id}\")] # Back to detail\n    ]\n    return InlineKeyboardMarkup(keyboard)\n\ndef manage_channel_groups_page_keyboard(user_subscription_id, yt_channel_name):\n    linked_groups = get_linked_tg_chats_for_subscription(user_subscription_id)\n    keyboard = []\n    if not linked_groups:\n        keyboard.append([InlineKeyboardButton(\"No TG groups linked yet for this channel.\", callback_data=\"noop_info\")])\n    for group_data in linked_groups:\n        title = group_data['telegram_chat_title'] or str(group_data['telegram_chat_id'])\n        label = f\"❌ Unlink '{title[:25]}{'...' if len(title)>25 else ''}'\"\n        keyboard.append([InlineKeyboardButton(label, callback_data=f\"{CB_UNLINK_TG_GROUP_PREFIX}{group_data['mapping_id']}\")])\n    keyboard.append([InlineKeyboardButton(\"⬅️ Back to Channel Details\", callback_data=f\"{CB_VIEW_CHANNEL_DETAIL_PREFIX}{user_subscription_id}\")])\n    return InlineKeyboardMarkup(keyboard)\n\ndef admin_panel_keyboard():\n    keyboard = [\n        [InlineKeyboardButton(\"📊 View All Users\", callback_data=CB_ADMIN_VIEW_USERS)],\n        [InlineKeyboardButton(\"🔗 View All Connections\", callback_data=CB_ADMIN_VIEW_CONNECTIONS)],\n        [InlineKeyboardButton(\"🔼 Manually Upgrade User\", callback_data=CB_ADMIN_MANUAL_UPGRADE_START)],\n        [InlineKeyboardButton(\"🔽 Manually Downgrade User\", callback_data=CB_ADMIN_MANUAL_DOWNGRADE_START)],\n        # [InlineKeyboardButton(\"📢 Broadcast Message\", callback_data=CB_ADMIN_BROADCAST_START)], # Add if broadcast is implemented\n        [back_to_main_menu_button()]\n    ]\n    return InlineKeyboardMarkup(keyboard)\n\n\n# ==============================================================================\n# MIDDLEWARE / DECORATORS\n# ==============================================================================\ndef check_mandatory_channel_join(func):\n    @wraps(func)\n    def wrapped(update: Update, context: CallbackContext, *args, **kwargs):\n        user_id = update.effective_user.id\n        if user_id == ADMIN_TELEGRAM_ID: # Admin bypasses this check\n             return func(update, context, *args, **kwargs)\n\n        if MANDATORY_JOIN_CHANNEL_ID:\n            try:\n                member = context.bot.get_chat_member(chat_id=MANDATORY_JOIN_CHANNEL_ID, user_id=user_id)\n                if member.status not in [ChatMember.MEMBER, ChatMember.ADMINISTRATOR, ChatMember.CREATOR]:\n                    join_channel_link = MANDATORY_JOIN_CHANNEL_ID\n                    if not MANDATORY_JOIN_CHANNEL_ID.startswith('@') and not MANDATORY_JOIN_CHANNEL_ID.startswith('-'):\n                        # This is an invalid ID if not username or numeric\n                        logger.error(f\"Invalid MANDATORY_JOIN_CHANNEL_ID format: {MANDATORY_JOIN_CHANNEL_ID}\")\n                        update.effective_message.reply_text(\"Bot configuration error (join channel). Please contact admin.\")\n                        return ConversationHandler.END if isinstance(func, ConversationHandler) else None\n                    \n                    if MANDATORY_JOIN_CHANNEL_ID.startswith('@'):\n                         join_channel_link = f\"https://t.me/{MANDATORY_JOIN_CHANNEL_ID[1:]}\"\n                    # For private channels by ID, you'd typically need an invite link which is harder to manage here.\n                    # Best to use public channel usernames.\n\n                    text = (\n                        f\"❗ To use this bot, please join our partner channel: {MANDATORY_JOIN_CHANNEL_NAME}\\n\"\n                        f\"Link: {join_channel_link}\\n\\n\"\n                        \"Once joined, please try your command again or press /start.\"\n                    )\n                    update.effective_message.reply_text(text, parse_mode=ParseMode.HTML) # HTML for link if needed\n                    return ConversationHandler.END if isinstance(context.dispatcher.handlers.get(0, {}).get(update.handler_index, None), ConversationHandler) else None\n                else: # User is a member\n                    return func(update, context, *args, **kwargs)\n            except BadRequest as e:\n                if \"chat not found\" in str(e).lower() or \"user not found\" in str(e).lower():\n                    logger.error(f\"Mandatory join channel '{MANDATORY_JOIN_CHANNEL_ID}' not found or user {user_id} not found by bot.\")\n                    update.effective_message.reply_text(\"Error verifying channel membership (channel/user not found). Please contact admin.\")\n                elif \"bot is not a member\" in str(e).lower():\n                    logger.error(f\"Bot is not a member of the mandatory join channel: {MANDATORY_JOIN_CHANNEL_ID}\")\n                    update.effective_message.reply_text(\"Bot configuration error (join check). Admin has been notified.\")\n                else:\n                    logger.error(f\"BadRequest checking join status for {user_id} in {MANDATORY_JOIN_CHANNEL_ID}: {e}\")\n                    update.effective_message.reply_text(\"Could not verify channel membership due to a temporary issue. Please try again.\")\n                return ConversationHandler.END if isinstance(context.dispatcher.handlers.get(0, {}).get(update.handler_index, None), ConversationHandler) else None\n            except Exception as e_gen:\n                logger.error(f\"Unexpected error checking join status for {user_id} in {MANDATORY_JOIN_CHANNEL_ID}: {e_gen}\")\n                update.effective_message.reply_text(\"An unexpected error occurred verifying channel membership. Please contact admin.\")\n                return ConversationHandler.END if isinstance(context.dispatcher.handlers.get(0, {}).get(update.handler_index, None), ConversationHandler) else None\n        else: # No mandatory channel configured\n            return func(update, context, *args, **kwargs)\n    return wrapped\n\n# ==============================================================================\n# TELEGRAM COMMAND HANDLERS\n# ==============================================================================\n@check_mandatory_channel_join\ndef start_command_handler(update: Update, context: CallbackContext):\n    user = update.effective_user\n    ref_code = context.args[0] if context.args and len(context.args[0]) > 3 else None # Basic validation for ref code\n\n    add_or_update_user(user.id, user.username, user.first_name, user.last_name, referred_by_code=ref_code)\n    user_db_details = get_user(user.id)\n\n    welcome_message = (\n        f\"👋 Welcome to the YouTube Auto-Poster Bot, {user.first_name or user.username}!\n\n\"\n        \"I can help you automatically post new videos from YouTube channels to your Telegram groups/channels.\n\n\"\n        \"🔹 Use `/addchannel <YouTube_URL> <Target_TG_ChatID_or_@Username>` to link a channel.\n\"\n        \"   (Ensure I'm an admin in the target chat with post permissions!)\n\"\n        \"🔹 Explore other options via the menu below or use `/help`.\n\"\n    )\n    if ref_code:\n         welcome_message += f\"\\nThanks for using a referral code! If your referrer helps {REFERRAL_TARGET_COUNT-1} more friends who upgrade, they get a reward! 🎉\\n\"\n    \n    if user_db_details and user_db_details['referral_code']:\n         welcome_message += f\"\\nYour personal referral code is: `{user_db_details['referral_code']}` (tap to copy).\n\"\n         welcome_message += f\"Share it! If {REFERRAL_TARGET_COUNT} friends use your code and then upgrade to premium, you get {REFERRAL_PREMIUM_DURATION_MONTHS} months of premium FREE!\"\n\n    update.message.reply_text(welcome_message, reply_markup=main_menu_keyboard(user.id), parse_mode=ParseMode.MARKDOWN)\n\n@check_mandatory_channel_join\ndef help_command_handler(update: Update, context: CallbackContext):\n    user_id = update.effective_user.id\n    user_tier = get_user_tier_limits(user_id)\n\n    help_text = (\n        \"✨ **YouTube Auto-Poster Bot Help** ✨\n\n\"\n        \"**Core Commands:**\n\"\n        \"`/start` - Initialize the bot & show main menu.\n\"\n        \"`/help` - Display this help message.\n\"\n        \"`/addchannel <YT_URL> <TG_ChatID_or_@Username>`\n\"\n        \"   Connects a YouTube channel to a Telegram chat.\n\"\n        \"   *Example (Public Channel)*: `/addchannel https://youtube.com/@MrBeast @mytelegramchannel`\n\"\n        \"   *Example (Group ID)*: `/addchannel https://youtube.com/channel/UC... -1001234567890`\n\"\n        \"   (Get Group ID from bots like `@RawDataBot` or `@getidsbot` by adding them to your group).\n\"\n        \"   *Important*: The bot must be an **admin** in the target Telegram chat with permission to **post messages**.\n\n\"\n        \"`/mychannels` - View and manage your linked YouTube channels (also in menu).\n\"\n        \"`/setreminder <YT_Video_URL> <Minutes>`\n\"\n        \"   Set a reminder for a specific YouTube video.\n\"\n        \"   *Example*: `/setreminder https://youtu.be/dQw4w9WgXcQ 60`\n\n\"\n        \"`/upgrade` - View premium upgrade options (also in menu).\n\"\n        \"`/myreferral` - Get your personal referral code and track your referral status.\n\n\"\n        \"**Your Current Tier: {user_tier['name']}**\n\"\n        f\"- Max YouTube Channels: {user_tier['max_yt_channels']}\n\"\n        f\"- Max Telegram links per YT Channel: {user_tier['max_tg_groups_per_yt']}\n\"\n        f\"- Max Total Telegram links: {user_tier['max_total_tg_groups']}\n\n\"\n        \"Explore the inline keyboard buttons from `/start` or the menu for quick access to most features.\n\"\n    )\n    if user_id == ADMIN_TELEGRAM_ID:\n        help_text += \"\n👑 **Admin Commands:**\n`/admin` - Access the admin panel.\n\"\n        help_text += \"`/simpayment <user_id> <plan_id> <amount_paisa>` - Simulate successful payment.\n\"\n        help_text += \"   Plan IDs: `plan_premium_1_monthly`, `plan_premium_3_quarterly`\n\"\n        help_text += \"   Example: `/simpayment 123456 plan_premium_1_monthly 11900`\n\"\n\n    update.message.reply_text(help_text, parse_mode=ParseMode.MARKDOWN, reply_markup=main_menu_keyboard(user_id))\n\n\n@check_mandatory_channel_join\ndef my_referral_command_handler(update: Update, context: CallbackContext):\n    user_id = update.effective_user.id\n    user = get_user(user_id)\n    if not user or not user['referral_code']:\n        update.message.reply_text(\"Could not find your referral code. Please try `/start` again.\", reply_markup=main_menu_keyboard(user_id))\n        return\n\n    text = f\"📣 **Your Referral Code: `{user['referral_code']}`** (tap to copy)\n\n\"\n    text += f\"Share this code with your friends! When they use it with `/start {user['referral_code']}` and then {REFERRAL_TARGET_COUNT} of them upgrade to any premium plan, you'll receive **{REFERRAL_PREMIUM_DURATION_MONTHS} months of premium access for FREE!**\n\n\"\n    \n    # Fetch referral progress\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT COUNT(id) as count FROM referrals_progress WHERE referrer_user_id = ? AND became_premium_date IS NOT NULL AND referrer_rewarded_date IS NULL\", (user_id,))\n        unrewarded_premium_referrals = cursor.fetchone()['count']\n        cursor.execute(\"SELECT COUNT(id) as count FROM referrals_progress WHERE referrer_user_id = ? AND became_premium_date IS NULL\", (user_id,))\n        signed_up_not_premium_referrals = cursor.fetchone()['count']\n\n    text += f\"**Your Referral Status:**\n\"\n    text += f\"- Friends who signed up & went premium (towards current reward): **{unrewarded_premium_referrals} / {REFERRAL_TARGET_COUNT}**\n\"\n    text += f\"- Friends who signed up (not yet premium): **{signed_up_not_premium_referrals}**\n\"\n\n    update.message.reply_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=main_menu_keyboard(user_id))\n\n# --- Conversation Handlers --- \n\n# Add Channel Conversation (Simplified to use arguments directly)\n@check_mandatory_channel_join\ndef addchannel_command_handler(update: Update, context: CallbackContext):\n    user_id = update.effective_user.id\n    if len(context.args) < 2:\n        update.message.reply_text(\n            \"Usage: `/addchannel <YouTube_Channel_URL_or_Video_URL> <Target_Telegram_GroupID_or_@ChannelUsername>`\\n\" \
            \"Example: `/addchannel https://youtube.com/@MrBeast @myPublicChannel`\\n\" \
            \"Example: `/addchannel https://youtube.com/watch?v=VIDEO_ID -100123456789` (for groups)\",\n            parse_mode=ParseMode.MARKDOWN\n        )\n        return\n\n    yt_url_input = context.args[0]\n    tg_chat_identifier = context.args[1]\n\n    user_tier = get_user_tier_limits(user_id)\n    if count_user_linked_yt_channels(user_id) >= user_tier['max_yt_channels']:\n        update.message.reply_text(f\"⚠️ You've reached your limit of {user_tier['max_yt_channels']} YouTube channels. Please /upgrade for more or remove an existing one.\")\n        return\n    if count_user_total_active_tg_group_links(user_id) >= user_tier['max_total_tg_groups']:\n        update.message.reply_text(f\"⚠️ You've reached your total limit of {user_tier['max_total_tg_groups']} Telegram group links. Please /upgrade or remove some.\")\n        return\n\n    msg = update.message.reply_text(f\"🔄 Processing YouTube URL: `{yt_url_input}`...\", parse_mode=ParseMode.MARKDOWN)\n\n    yt_channel_api_id, error_resolve = extract_yt_channel_id_from_url(yt_url_input)\n    if error_resolve or not yt_channel_api_id:\n        msg.edit_text(f\"❌ Error resolving YouTube URL: {error_resolve or 'Could not extract Channel ID.'} Please provide a direct channel link (e.g., .../channel/UCxxx, .../@handle) or a video URL from the channel.\")\n        return\n\n    channel_api_details, error_fetch_details = get_yt_channel_details(yt_channel_api_id)\n    if error_fetch_details or not channel_api_details:\n        msg.edit_text(f\"❌ Error fetching YouTube channel details for ID `{yt_channel_api_id}`: {error_fetch_details or 'Channel not found.'}\")\n        return\n    yt_channel_name = channel_api_details['snippet']['title']\n\n    msg.edit_text(f\"🔄 YouTube Channel: **{yt_channel_name}** (`{yt_channel_api_id}`).\n🔄 Validating Telegram chat: `{tg_chat_identifier}`...\", parse_mode=ParseMode.MARKDOWN)\n\n    try:\n        # Resolve Telegram chat ID and check permissions\n        # Allow numeric IDs (positive for users, negative for groups/channels) and @usernames\n        if tg_chat_identifier.startswith('@'):\n            actual_tg_chat_id = tg_chat_identifier # Use username directly for API calls\n        else:\n            try:\n                actual_tg_chat_id = int(tg_chat_identifier)\n            except ValueError:\n                msg.edit_text(f\"❌ Invalid Telegram Chat Identifier: '{tg_chat_identifier}'. Must be a numeric ID or @username.\")\n                return\n\n        chat_info = context.bot.get_chat(actual_tg_chat_id)\n        tg_chat_id_numeric = chat_info.id # Always numeric from here\n        tg_chat_title_display = chat_info.title or chat_info.username or str(tg_chat_id_numeric)\n\n        bot_member_status = context.bot.get_chat_member(tg_chat_id_numeric, context.bot.id)\n        if bot_member_status.status != ChatMember.ADMINISTRATOR or not bot_member_status.can_post_messages:\n            msg.edit_text(f\"⚠️ I must be an **admin with 'Post messages' permission** in '{tg_chat_title_display}' ({tg_chat_id_numeric}) to work.\nPlease grant permissions and try again.\")\n            return\n\n        # All checks passed, proceed with DB operations\n        yt_channel_db_id = add_or_get_yt_channel_in_db(yt_channel_api_id, yt_channel_name)\n        user_subscription_id = add_user_subscription_to_yt_channel(user_id, yt_channel_db_id)\n\n        if not user_subscription_id: # Should not happen if DB logic is correct\n             msg.edit_text(f\"❌ Internal error creating subscription for '{yt_channel_name}'. Please try again.\")\n             return\n        \n        # Check per-YT channel group limit\n        if count_tg_links_for_specific_yt_subscription(user_subscription_id) >= user_tier['max_tg_groups_per_yt']:\n            msg.edit_text(f\"⚠️ You've reached the limit of {user_tier['max_tg_groups_per_yt']} Telegram links for the YouTube channel '{yt_channel_name}'.\")\n            return\n\n        mapping_id = link_subscription_to_tg_chat(user_subscription_id, tg_chat_id_numeric, tg_chat_title_display)\n        if mapping_id:\n            msg.edit_text(\n                f\"✅ Success! YouTube channel **'{yt_channel_name}'** is now linked to Telegram chat **'{tg_chat_title_display}'**.\\n\"\n                f\"I'll start checking for new videos. The first check might take up to {VIDEO_CHECK_INTERVAL_MINUTES} minutes.\",\n                parse_mode=ParseMode.MARKDOWN\n            )\n            # Trigger an immediate check for this new channel if desired (optional)\n            # context.job_queue.run_once(specific_channel_check_job, 0, context={'yt_channel_db_id': yt_channel_db_id})\n        else:\n            msg.edit_text(f\"⚠️ This YouTube channel ('{yt_channel_name}') is already linked to the Telegram chat ('{tg_chat_title_display}') for your account.\")\n\n    except BadRequest as e_bad_req:\n        logger.warning(f\"BadRequest linking to Telegram chat {tg_chat_identifier}: {e_bad_req}\")\n        if \"chat not found\" in str(e_bad_req).lower():\n            msg.edit_text(f\"❌ Error: Telegram Chat '{tg_chat_identifier}' not found or I don't have access.\")\n        elif \"bot was kicked\" in str(e_bad_req).lower() or \"not a member\" in str(e_bad_req).lower():\n             msg.edit_text(f\"❌ Error: I'm not a member of '{tg_chat_identifier}' or was kicked. Please add me as an admin.\")\n        else:\n            msg.edit_text(f\"❌ Error validating Telegram chat '{tg_chat_identifier}': {e_bad_req.message}\")\n    except TimedOut:\n        msg.edit_text(\"❌ Telegram API timed out. Please try again shortly.\")\n    except Exception as e_general_tg:\n        logger.error(f\"Unexpected error during /addchannel TG processing for {tg_chat_identifier}: {e_general_tg}\")\n        msg.edit_text(f\"❌ An unexpected error occurred with Telegram chat '{tg_chat_identifier}'. Please ensure it's correct and I have permissions.\")\n\n# Set Reminder Conversation\n@check_mandatory_channel_join\ndef setreminder_command_handler(update: Update, context: CallbackContext):\n    # /setreminder <URL> <Minutes>\n    if len(context.args) == 2:\n        context.user_data['reminder_video_url'] = context.args[0]\n        try:\n            context.user_data['reminder_minutes_input'] = int(context.args[1])\n            return _process_reminder_final_step(update, context) # Directly process\n        except ValueError:\n            update.message.reply_text(\"Invalid number of minutes. Please provide a whole number.\")\n            # Fall through to ask for URL if needed, or end conversation if this was the final step attempted.\n            # For now, just end if format is bad from command args.\n            return ConversationHandler.END\n    else:\n        # Start conversation by asking for URL\n        update.message.reply_text(\n            \"Okay, let's set a video reminder. Please send me the YouTube video URL you want to be reminded about.\",\n            reply_markup=InlineKeyboardMarkup([[cancel_conversation_button()]])\n        )\n        return ASK_REMINDER_VIDEO_URL\n\ndef reminder_ask_video_url_from_menu(update: Update, context: CallbackContext):\n    query = update.callback_query\n    query.answer()\n    query.edit_message_text(\n        \"Okay, let's set a video reminder. Please send me the YouTube video URL you want to be reminded about.\",\n        reply_markup=InlineKeyboardMarkup([[cancel_conversation_button()]])\n    )\n    return ASK_REMINDER_VIDEO_URL\n\ndef reminder_received_video_url(update: Update, context: CallbackContext):\n    video_url = update.message.text.strip()\n    # Basic URL validation (can be more sophisticated)\n    if not (video_url.startswith(\"https://www.youtube.com/\") or video_url.startswith(\"https://youtu.be/\")):\n        update.message.reply_text(\"That doesn't look like a valid YouTube URL. Please try again or cancel.\", \n                                  reply_markup=InlineKeyboardMarkup([[cancel_conversation_button()]]))\n        return ASK_REMINDER_VIDEO_URL # Stay in this state\n    \n    context.user_data['reminder_video_url'] = video_url\n    update.message.reply_text(\"Great! Now, in how many minutes from now should I remind you? (e.g., 60)\", \n                              reply_markup=InlineKeyboardMarkup([[cancel_conversation_button()]]))\n    return ASK_REMINDER_DURATION_MINUTES\n\ndef reminder_received_duration_minutes(update: Update, context: CallbackContext):\n    try:\n        minutes = int(update.message.text.strip())\n        if minutes <= 0:\n            update.message.reply_text(\"Minutes must be a positive number. Please try again.\", \n                                      reply_markup=InlineKeyboardMarkup([[cancel_conversation_button()]]))\n            return ASK_REMINDER_DURATION_MINUTES # Stay\n        context.user_data['reminder_minutes_input'] = minutes\n        return _process_reminder_final_step(update, context)\n    except ValueError:\n        update.message.reply_text(\"That's not a valid number. Please enter minutes as a whole number (e.g., 30, 120).\", \n                                  reply_markup=InlineKeyboardMarkup([[cancel_conversation_button()]]))\n        return ASK_REMINDER_DURATION_MINUTES # Stay\n\ndef _process_reminder_final_step(update: Update, context: CallbackContext):\n    user_id = update.effective_user.id\n    video_url = context.user_data.get('reminder_video_url')\n    minutes_val = context.user_data.get('reminder_minutes_input')\n\n    if not (video_url and isinstance(minutes_val, int) and minutes_val > 0):\n        update.effective_message.reply_text(\"Something went wrong with the reminder details. Please start over using /setreminder.\", \n                                            reply_markup=main_menu_keyboard(user_id))\n        return ConversationHandler.END\n\n    video_info, error_msg = get_yt_video_details_from_url_for_reminder(video_url)\n    if error_msg or not video_info:\n        update.effective_message.reply_text(f\"❌ Could not get details for video: {video_url}. Error: {error_msg or 'Video not found.'}\nPlease ensure the URL is correct and try again.\", \n                                            reply_markup=main_menu_keyboard(user_id))\n        return ConversationHandler.END\n\n    remind_at_utc = datetime.now(timezone.utc) + timedelta(minutes=minutes_val)\n    add_reminder_to_db(user_id, video_url, video_info['title'], remind_at_utc)\n\n    success_message = (\n        f\"🔔 Reminder set for video: **{video_info['title']}**!\\n\"\n        f\"I'll remind you in {minutes_val} minutes (at approximately {remind_at_utc.strftime('%Y-%m-%d %H:%M')} UTC).\"\n    )\n    update.effective_message.reply_text(success_message, parse_mode=ParseMode.MARKDOWN, reply_markup=main_menu_keyboard(user_id))\n    context.user_data.clear()\n    return ConversationHandler.END\n\ndef get_yt_video_details_from_url_for_reminder(video_url):\n    # Simplified version of get_yt_video_details, as we mainly need title\n    match = re.search(r\"(?:v=|/embed/|shorts/|\\.be/)([a-zA-Z0-9_-]{11})\", video_url)\n    if not match: return None, \"Invalid YouTube video URL format.\"\n    video_id = match.group(1)\n\n    youtube = get_youtube_service()\n    if not youtube: return None, \"YouTube API service unavailable.\"\n    try:\n        request = youtube.videos().list(part=\"snippet\", id=video_id)\n        response = request.execute()\n        if response.get(\"items\"):\n            return {\"id\": video_id, \"title\": response[\"items\"][0][\"snippet\"][\"title\"]}, None\n        return None, \"Video not found by API.\"\n    except GoogleApiHttpError as e_api:\n        logger.warning(f\"API error fetching video title for reminder {video_id}: {e_api}\")\n        if \"quotaExceeded\" in str(e_api): return None, \"YouTube API quota exceeded.\"\n        return None, \"Could not fetch video title (API error).\"\n    except Exception as e_gen:\n        logger.warning(f\"General error fetching video title for reminder {video_id}: {e_gen}\")\n        return None, \"Could not fetch video title (unexpected error).\"\n\n\n# Add Group to Existing YT Channel (Conversation started from inline button)\ndef add_group_to_channel_start_convo(update: Update, context: CallbackContext):\n    query = update.callback_query\n    user_id = query.from_user.id\n    try:\n        user_subscription_id = int(query.data.split('_')[-1])\n    except (IndexError, ValueError):\n        query.answer(\"Error: Invalid channel reference.\", show_alert=True)\n        return ConversationHandler.END\n\n    context.user_data['current_user_subscription_id'] = user_subscription_id\n    user_tier = get_user_tier_limits(user_id)\n    if count_user_total_active_tg_group_links(user_id) >= user_tier['max_total_tg_groups']:\n        query.answer(f\"You've reached your total limit of {user_tier['max_total_tg_groups']} TG links.\", show_alert=True)\n        return ConversationHandler.END\n    if count_tg_links_for_specific_yt_subscription(user_subscription_id) >= user_tier['max_tg_groups_per_yt']:\n        query.answer(f\"This YT channel reached its {user_tier['max_tg_groups_per_yt']} TG link limit.\", show_alert=True)\n        return ConversationHandler.END\n\n    query.answer()\n    # Fetch YT channel name for context\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT yc.youtube_channel_name FROM user_youtube_subscriptions uys JOIN youtube_channels yc ON uys.yt_channel_db_id = yc.id WHERE uys.id = ?\", (user_subscription_id,))\n        yt_channel = cursor.fetchone()\n        yt_channel_name_display = yt_channel['youtube_channel_name'] if yt_channel else \"Selected YouTube Channel\"\n\n    query.edit_message_text(\n        f\"Okay, linking a new Telegram chat to **{yt_channel_name_display}**.\\n\\n\"\n        \"Please send the **Target Telegram Group ID** (e.g., -100xxxx) or **Public Channel Username** (e.g., @mychannel).\\n\\n\"\n        \"ℹ️ *Remember, I need to be an admin there with post permissions!*\",\n        parse_mode=ParseMode.MARKDOWN,\n        reply_markup=InlineKeyboardMarkup([[cancel_conversation_button()]])\n    )\n    return ASK_TG_CHAT_ID_FOR_LINKING\n\ndef add_group_to_channel_received_tg_chat_id(update: Update, context: CallbackContext):\n    user_id = update.effective_user.id\n    tg_chat_identifier = update.message.text.strip()\n    user_subscription_id = context.user_data.get('current_user_subscription_id')\n\n    if not user_subscription_id:\n        update.message.reply_text(\"Error: Context lost. Please restart this action from 'My Channels'.\", reply_markup=main_menu_keyboard(user_id))\n        return ConversationHandler.END\n\n    # Fetch YT channel name again for messages\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT yc.youtube_channel_name FROM user_youtube_subscriptions uys JOIN youtube_channels yc ON uys.yt_channel_db_id = yc.id WHERE uys.id = ?\", (user_subscription_id,))\n        yt_channel = cursor.fetchone()\n        yt_channel_name_display = yt_channel['youtube_channel_name'] if yt_channel else \"Selected YouTube Channel\"\n\n    try:\n        if tg_chat_identifier.startswith('@'):\n            actual_tg_chat_id = tg_chat_identifier\n        else:\n            try: actual_tg_chat_id = int(tg_chat_identifier)\n            except ValueError:\n                update.message.reply_text(\"Invalid Telegram Chat Identifier. Must be numeric or @username. Try again or cancel.\",\n                                          reply_markup=InlineKeyboardMarkup([[cancel_conversation_button()]]))\n                return ASK_TG_CHAT_ID_FOR_LINKING\n\n        chat_info = context.bot.get_chat(actual_tg_chat_id)\n        tg_chat_id_numeric = chat_info.id\n        tg_chat_title_display = chat_info.title or chat_info.username or str(tg_chat_id_numeric)\n\n        bot_member_status = context.bot.get_chat_member(tg_chat_id_numeric, context.bot.id)\n        if bot_member_status.status != ChatMember.ADMINISTRATOR or not bot_member_status.can_post_messages:\n            update.message.reply_text(f\"⚠️ I must be an admin with 'Post messages' permission in '{tg_chat_title_display}'. Please grant permissions and try again or cancel.\",\n                                      reply_markup=InlineKeyboardMarkup([[cancel_conversation_button()]]))\n            return ASK_TG_CHAT_ID_FOR_LINKING\n        \n        mapping_id = link_subscription_to_tg_chat(user_subscription_id, tg_chat_id_numeric, tg_chat_title_display)\n        if mapping_id:\n            update.message.reply_text(f\"✅ Success! '{yt_channel_name_display}' is now also linked to '{tg_chat_title_display}'.\", \n                                      reply_markup=channel_detail_page_keyboard(user_subscription_id, yt_channel_name_display)) # Back to channel details\n        else:\n            update.message.reply_text(f\"⚠️ '{yt_channel_name_display}' is already linked to '{tg_chat_title_display}'.\",\n                                      reply_markup=channel_detail_page_keyboard(user_subscription_id, yt_channel_name_display))\n        context.user_data.clear()\n        return ConversationHandler.END\n\n    except BadRequest as e_br:\n        logger.warning(f\"BadRequest linking group in convo {tg_chat_identifier}: {e_br}\")\n        error_text = f\"Error with Telegram chat '{tg_chat_identifier}': {e_br.message}. Ensure it's correct and I have access. Try again or cancel.\"\n        if \"chat not found\" in str(e_br).lower(): error_text = f\"Chat '{tg_chat_identifier}' not found.\"\n        update.message.reply_text(error_text, reply_markup=InlineKeyboardMarkup([[cancel_conversation_button()]]))\n        return ASK_TG_CHAT_ID_FOR_LINKING\n    except Exception as e_gen:\n        logger.error(f\"Unexpected error linking group in convo {tg_chat_identifier}: {e_gen}\")\n        update.message.reply_text(\"An unexpected error occurred. Please try again or cancel.\", reply_markup=InlineKeyboardMarkup([[cancel_conversation_button()]]))\n        return ASK_TG_CHAT_ID_FOR_LINKING\n\n# Generic Cancel for Conversations\ndef cancel_conversation_handler(update: Update, context: CallbackContext):\n    user_id = update.effective_user.id\n    message_text = \"Operation cancelled.\"\n    reply_markup = main_menu_keyboard(user_id)\n    \n    if update.callback_query:\n        query = update.callback_query\n        query.answer()\n        # Try to intelligently determine what menu to return to if possible from user_data state\n        # For simplicity now, just main menu.\n        # if context.user_data.get('current_user_subscription_id'):\n        #     # Potentially return to channel detail page\n        #     pass \n        query.edit_message_text(text=f\"{message_text} Returning to main menu.\", reply_markup=reply_markup)\n    else:\n        update.message.reply_text(text=f\"{message_text} Returning to main menu.\", reply_markup=reply_markup)\n    \n    context.user_data.clear() # Clear any conversation state\n    return ConversationHandler.END\n\n# ==============================================================================\n# ADMIN COMMANDS AND CONVERSATIONS\n# ==============================================================================\n@check_mandatory_channel_join # Admin also subject to this if not ADMIN_TELEGRAM_ID matches\ndef admin_command_handler(update: Update, context: CallbackContext):\n    if update.effective_user.id != ADMIN_TELEGRAM_ID:\n        update.message.reply_text(\"⛔ You are not authorized for this command.\", reply_markup=main_menu_keyboard(update.effective_user.id))\n        return\n    update.message.reply_text(\"👑 Welcome to the Admin Panel!\", reply_markup=admin_panel_keyboard())\n\n# Admin Manual User Upgrade Conversation\ndef admin_manual_upgrade_start(update: Update, context: CallbackContext):\n    query = update.callback_query\n    if query.from_user.id != ADMIN_TELEGRAM_ID: query.answer(\"Unauthorized!\"); return ConversationHandler.END\n    query.answer()\n    query.edit_message_text(\"Enter the Telegram User ID of the user you want to manually upgrade to premium:\",\n                            reply_markup=InlineKeyboardMarkup([[cancel_conversation_button()]]))\n    return ASK_ADMIN_UPGRADE_USER_ID\n\ndef admin_manual_upgrade_received_user_id(update: Update, context: CallbackContext):\n    if update.effective_user.id != ADMIN_TELEGRAM_ID: return ConversationHandler.END\n    try:\n        target_user_id = int(update.message.text.strip())\n        user_to_upgrade = get_user(target_user_id)\n        if not user_to_upgrade:\n            update.message.reply_text(f\"User with ID {target_user_id} not found. Ensure they've started the bot.\",\n                                      reply_markup=InlineKeyboardMarkup([[cancel_conversation_button()]]))\n            return ASK_ADMIN_UPGRADE_USER_ID # Re-ask or cancel\n        context.user_data['admin_target_user_id'] = target_user_id\n        context.user_data['admin_target_username'] = user_to_upgrade['username'] or user_to_upgrade['first_name']\n        update.message.reply_text(f\"Upgrading user {context.user_data['admin_target_username']} (ID: {target_user_id}).\\nFor how many months should their premium be active? (e.g., 1, 3, 12)\",\n                                  reply_markup=InlineKeyboardMarkup([[cancel_conversation_button()]]))\n        return ASK_ADMIN_UPGRADE_MONTHS\n    except ValueError:\n        update.message.reply_text(\"Invalid User ID. Please enter a numeric ID.\", reply_markup=InlineKeyboardMarkup([[cancel_conversation_button()]]))\n        return ASK_ADMIN_UPGRADE_USER_ID\n\ndef admin_manual_upgrade_received_months(update: Update, context: CallbackContext):\n    if update.effective_user.id != ADMIN_TELEGRAM_ID: return ConversationHandler.END\n    try:\n        months = int(update.message.text.strip())\n        target_user_id = context.user_data['admin_target_user_id']\n        target_username = context.user_data['admin_target_username']\n        if months <= 0:\n            update.message.reply_text(\"Months must be a positive number. Try again.\", reply_markup=InlineKeyboardMarkup([[cancel_conversation_button()]]))\n            return ASK_ADMIN_UPGRADE_MONTHS\n\n        # Use a generic plan name for admin grants\n        admin_plan_name = f\"Admin Granted Premium ({months} months)\"\n        success, message = set_user_premium_status(target_user_id, \"ADMIN_GRANT\", admin_plan_name, months, 0, f\"ADMIN_ID_{ADMIN_TELEGRAM_ID}\")\n        \n        if success:\n            update.message.reply_text(f\"✅ User {target_username} (ID: {target_user_id}) has been upgraded for {months} months.\\n{message}\", reply_markup=admin_panel_keyboard())\n            try:\n                context.bot.send_message(target_user_id, f\"🎉 Hooray! An admin has granted you {months} months of premium access to the YouTube Auto-Poster Bot! Enjoy the enhanced features.\")\n            except TelegramError as e_notify:\n                logger.warning(f\"Could not notify user {target_user_id} of manual upgrade: {e_notify}\")\n        else:\n            update.message.reply_text(f\"❌ Failed to upgrade user {target_username} (ID: {target_user_id}). Reason: {message}\", reply_markup=admin_panel_keyboard())\n        context.user_data.clear()\n        return ConversationHandler.END\n    except ValueError:\n        update.message.reply_text(\"Invalid number of months. Please enter a number.\", reply_markup=InlineKeyboardMarkup([[cancel_conversation_button()]]))\n        return ASK_ADMIN_UPGRADE_MONTHS\n\n# Admin Manual User Downgrade Conversation (similar structure to upgrade)\n@check_mandatory_channel_join\ndef simulate_payment_command_handler(update: Update, context: CallbackContext):\n    if update.effective_user.id != ADMIN_TELEGRAM_ID:\n        update.message.reply_text(\"⛔ Unauthorized for /simpayment.\")\n        return\n\n    if len(context.args) != 3:\n        update.message.reply_text(\"Usage: `/simpayment <target_user_id> <plan_id> <amount_paisa>`\\n\" \
                                  f\"Plan IDs: `{PREMIUM_PLAN_1_ID}`, `{PREMIUM_PLAN_2_ID}`\")\n        return\n\n    try:\n        target_user_id = int(context.args[0])\n        plan_id_arg = context.args[1]\n        amount_paisa_arg = int(context.args[2])\n\n        target_user = get_user(target_user_id)\n        if not target_user:\n            update.message.reply_text(f\"User {target_user_id} not found.\")\n            return\n\n        plan_name, plan_duration_months = \"\", 0\n        if plan_id_arg == PREMIUM_PLAN_1_ID:\n            plan_name, plan_duration_months = PREMIUM_PLAN_1_NAME, PREMIUM_PLAN_1_DURATION_MONTHS\n        elif plan_id_arg == PREMIUM_PLAN_2_ID:\n            plan_name, plan_duration_months = PREMIUM_PLAN_2_NAME, PREMIUM_PLAN_2_DURATION_MONTHS\n        else:\n            update.message.reply_text(f\"Invalid Plan ID. Use `{PREMIUM_PLAN_1_ID}` or `{PREMIUM_PLAN_2_ID}`.\")\n            return\n\n        mock_payment_id = f\"sim_pay_{target_user_id}_{int(time.time())}\"\n        mock_order_id = f\"sim_order_{target_user_id}_{int(time.time())}\"\n\n        success, message = process_successful_payment(target_user_id, plan_id_arg, plan_name, plan_duration_months, amount_paisa_arg, mock_payment_id, mock_order_id)\n\n        if success:\n            update.message.reply_text(f\"✅ Simulated payment processed for user {target_user_id} ({target_user['username']}).\\n{message}\")\n            try:\n                context.bot.send_message(target_user_id, f\"🎉 Your account has been upgraded to {plan_name} via admin simulation!\\n{message}\")\n            except TelegramError as e_notify:\n                logger.warning(f\"Could not notify user {target_user_id} of simulated payment upgrade: {e_notify}\")\n        else:\n            update.message.reply_text(f\"❌ Simulated payment FAILED for user {target_user_id}.\\n{message}\")\n\n    except ValueError:\n        update.message.reply_text(\"Invalid User ID or Amount (must be numbers). Format: `/simpayment <UID> <PlanID> <PaisaAmount>`\")\n    except Exception as e_sim:\n        logger.error(f\"Error in /simpayment: {e_sim}\")\n        update.message.reply_text(f\"An unexpected error occurred during simulation: {e_sim}\")\n\n\n# ==============================================================================\n# CALLBACK QUERY HANDLER (MAIN ROUTER FOR INLINE BUTTONS)\n# ==============================================================================\n@check_mandatory_channel_join\ndef callback_query_router(update: Update, context: CallbackContext):\n    query = update.callback_query\n    user_id = query.from_user.id\n    data = query.data\n\n    # Always answer callback query quickly\n    try: query.answer()\n    except BadRequest: pass # If already answered or other issue, ignore for now\n\n    # --- Main Menu Navigation & Info --- \n    if data == CB_MAIN_MENU:\n        query.edit_message_text(\"🏡 Welcome back to the Main Menu!\", reply_markup=main_menu_keyboard(user_id))\n    elif data == CB_HELP_INFO:\n        # Re-use help_command logic if possible, or have dedicated text\n        # For simplicity, this is a placeholder call to the command's logic.\n        # In a real app, you'd extract the text generation into a helper function.\n        help_command_handler(update, context) # This will send a new message; for edit, needs refactor\n        query.edit_message_text(\"Displaying help information via a new message. You can also use /help.\") # Edit placeholder\n    elif data == CB_MY_REFERRAL_INFO:\n        my_referral_command_handler(update, context) # This will send a new message\n        query.edit_message_text(\"Displaying referral information via a new message. You can also use /myreferral.\") # Edit placeholder\n    \n    # --- Upgrade Plan Flow --- \n    elif data == CB_UPGRADE_OPTIONS:\n        user_tier = get_user_tier_limits(user_id)\n        text = f\"🚀 **Upgrade Your Plan**\\n\\nYour current tier: **{user_tier['name']}**\\n\"\n        if user_tier['is_premium']:\n            user = get_user(user_id)\n            expiry_dt = user['premium_expiry_date']\n            if isinstance(expiry_dt, str): expiry_dt = datetime.fromisoformat(expiry_dt)\n            text += f\"Premium active until: {expiry_dt.strftime('%Y-%m-%d %H:%M')} UTC\\n\"\n        text += \"\\nChoose a plan to upgrade or extend your subscription:\"\n        query.edit_message_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=upgrade_options_page_keyboard(user_id))\n    \n    elif data == CB_PROCESS_UPGRADE_PLAN_1 or data == CB_PROCESS_UPGRADE_PLAN_2:\n        plan_id, plan_name, amount_paisa = \"\", \"\", 0\n        if data == CB_PROCESS_UPGRADE_PLAN_1:\n            plan_id, plan_name, amount_paisa = PREMIUM_PLAN_1_ID, PREMIUM_PLAN_1_NAME, PREMIUM_PLAN_1_PRICE\n        else:\n            plan_id, plan_name, amount_paisa = PREMIUM_PLAN_2_ID, PREMIUM_PLAN_2_NAME, PREMIUM_PLAN_2_PRICE\n\n        order, error_msg = create_razorpay_order_for_plan(plan_id, plan_name, amount_paisa, user_id)\n        if error_msg or not order:\n            query.edit_message_text(f\"⚠️ Could not create payment order: {error_msg or 'Unknown error'}.\\nPlease try again later or contact support.\", reply_markup=upgrade_options_page_keyboard(user_id))\n            return\n\n        payment_text = (\n            f\"You selected: **{plan_name}** (₹{amount_paisa/100:.2f}).\\n\"\n            f\"A Razorpay order (ID: `{order['id']}`) has been notionally created.\\n\\n\"\n            \"**For this Colab Bot Demo:**\\n\"\n            \"To simulate a successful payment, an admin can use the command:\\n\"\n            f\"`/simpayment {user_id} {plan_id} {amount_paisa}`\\n\\n\"\n            \"In a live bot, you would be redirected to Razorpay to complete the payment. After payment, your plan would activate automatically.\"\n        )\n        query.edit_message_text(payment_text, parse_mode=ParseMode.MARKDOWN, reply_markup=upgrade_options_page_keyboard(user_id))\n\n    # --- My Channels Management --- \n    elif data == CB_MY_CHANNELS:\n        query.edit_message_text(\"🔗 **Your Linked YouTube Channels:**\\nSelect a channel to manage its details and linked Telegram chats.\", \n                                parse_mode=ParseMode.MARKDOWN, reply_markup=my_channels_page_keyboard(user_id))\n    \n    elif data.startswith(CB_VIEW_CHANNEL_DETAIL_PREFIX):\n        try: user_subscription_id = int(data.split('_')[-1])\n        except (IndexError, ValueError): query.answer(\"Invalid channel reference.\", show_alert=True); return\n        \n        with get_db_connection() as conn:\n            cursor=conn.cursor()\n            cursor.execute(\"SELECT yc.youtube_channel_name FROM user_youtube_subscriptions uys JOIN youtube_channels yc ON uys.yt_channel_db_id=yc.id WHERE uys.id=? AND uys.user_id=?\", (user_subscription_id, user_id))\n            channel_data = cursor.fetchone()\n        \n        if channel_data:\n            yt_channel_name = channel_data['youtube_channel_name']\n            text = f\"🛠️ Managing YouTube Channel: **{yt_channel_name}**\\nWhat would you like to do?\"\n            query.edit_message_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=channel_detail_page_keyboard(user_subscription_id, yt_channel_name))\n        else:\n            query.answer(\"Channel not found or access denied.\", show_alert=True)\n            query.edit_message_text(\"Error: Channel not found.\", reply_markup=my_channels_page_keyboard(user_id))\n\n    elif data.startswith(CB_MANAGE_CHANNEL_GROUPS_PREFIX):\n        try: user_subscription_id = int(data.split('_')[-1])\n        except: query.answer(\"Invalid channel ref.\", show_alert=True); return\n        # Fetch YT channel name for context\n        with get_db_connection() as conn: cursor=conn.cursor(); cursor.execute(\"SELECT yc.youtube_channel_name FROM user_youtube_subscriptions uys JOIN youtube_channels yc ON uys.yt_channel_db_id=yc.id WHERE uys.id=?\", (user_subscription_id,)); yt_ch = cursor.fetchone()\n        yt_channel_name = yt_ch['youtube_channel_name'] if yt_ch else \"Selected YT Channel\"\n        query.edit_message_text(f\"📋 Linked Telegram Chats for: **{yt_channel_name}**\\nSelect a chat to unlink it.\", parse_mode=ParseMode.MARKDOWN, reply_markup=manage_channel_groups_page_keyboard(user_subscription_id, yt_channel_name))\n\n    elif data.startswith(CB_UNLINK_TG_GROUP_PREFIX):\n        try: mapping_id = int(data.split('_')[-1])\n        except: query.answer(\"Invalid mapping ref.\", show_alert=True); return\n        # Get user_subscription_id for going back to the correct menu\n        with get_db_connection() as conn: cursor=conn.cursor(); cursor.execute(\"SELECT user_subscription_id FROM channel_group_mappings WHERE id=?\",(mapping_id,)); mapping_data = cursor.fetchone()\n        if not mapping_data: query.answer(\"Mapping not found.\", show_alert=True); return\n        user_subscription_id = mapping_data['user_subscription_id']\n        # Ensure user owns this subscription implicitly by navigation flow, but can add explicit check\n        \n        if unlink_tg_chat_from_subscription(mapping_id):\n            query.answer(\"Telegram chat unlinked successfully!\", show_alert=True)\n        else:\n            query.answer(\"Error unlinking Telegram chat.\", show_alert=True)\n        # Refresh the manage groups page\n        with get_db_connection() as conn: cursor=conn.cursor(); cursor.execute(\"SELECT yc.youtube_channel_name FROM user_youtube_subscriptions uys JOIN youtube_channels yc ON uys.yt_channel_db_id=yc.id WHERE uys.id=?\", (user_subscription_id,)); yt_ch = cursor.fetchone()\n        yt_channel_name = yt_ch['youtube_channel_name'] if yt_ch else \"Selected YT Channel\"\n        query.edit_message_text(f\"📋 Linked Telegram Chats for: **{yt_channel_name}**\", parse_mode=ParseMode.MARKDOWN, reply_markup=manage_channel_groups_page_keyboard(user_subscription_id, yt_channel_name))\n\n    elif data.startswith(CB_CONFIRM_DELETE_YT_CHANNEL_PREFIX):\n        try: user_subscription_id = int(data.split('_')[-1])\n        except: query.answer(\"Invalid channel ref.\", show_alert=True); return\n        with get_db_connection() as conn: cursor=conn.cursor(); cursor.execute(\"SELECT yc.youtube_channel_name FROM user_youtube_subscriptions uys JOIN youtube_channels yc ON uys.yt_channel_db_id=yc.id WHERE uys.id=? AND uys.user_id=?\",(user_subscription_id, user_id)); ch_data=cursor.fetchone()\n        if ch_data:\n            query.edit_message_text(f\"⚠️ Are you sure you want to unlink the YouTube channel **'{ch_data['youtube_channel_name']}'** from the bot?\\nThis will remove all its linked Telegram chats and stop all video posting for it.\", \n                                    parse_mode=ParseMode.MARKDOWN, reply_markup=confirm_delete_yt_channel_keyboard(user_subscription_id, ch_data['youtube_channel_name']))\n        else: query.answer(\"Channel not found.\", show_alert=True)\n\n    elif data.startswith(CB_DO_DELETE_YT_CHANNEL_PREFIX):\n        try: user_subscription_id = int(data.split('_')[-1])\n        except: query.answer(\"Invalid channel ref.\", show_alert=True); return\n        # Add check: Ensure this subscription_id belongs to user_id\n        if delete_user_yt_channel_subscription(user_subscription_id):\n            query.answer(\"YouTube channel unlinked successfully!\", show_alert=True)\n            query.edit_message_text(\"Channel unlinked. Your channel list has been updated.\", reply_markup=my_channels_page_keyboard(user_id))\n        else:\n            query.answer(\"Error unlinking YouTube channel.\", show_alert=True)\n            # Refresh current view if needed, or MyChannels page\n            query.edit_message_text(\"Could not unlink channel. Please try again.\", reply_markup=my_channels_page_keyboard(user_id))\n\n    # --- Admin Panel Navigation --- \n    elif data == CB_ADMIN_PANEL:\n        if user_id != ADMIN_TELEGRAM_ID: query.answer(\"Unauthorized!\", show_alert=True); return\n        query.edit_message_text(\"👑 Admin Panel\", reply_markup=admin_panel_keyboard())\n    \n    elif data == CB_ADMIN_VIEW_USERS:\n        if user_id != ADMIN_TELEGRAM_ID: query.answer(\"Unauthorized!\", show_alert=True); return\n        users_list = get_all_users_for_admin()\n        if not users_list:\n            query.edit_message_text(\"No users found in the database yet.\", reply_markup=admin_panel_keyboard())\n            return\n        text = \"👥 **All Bot Users (Recent First):**\\n\\n\"\n        count = 0\n        for u_dict in users_list:\n            expiry_str = \"N/A\"\n            if u_dict['premium_expiry_date']:\n                expiry_dt = u_dict['premium_expiry_date']\n                if isinstance(expiry_dt, str): expiry_dt = datetime.fromisoformat(expiry_dt)\n                expiry_str = expiry_dt.strftime('%Y-%m-%d %H:%M UTC')\n            \n            is_prem_active = u_dict['is_premium'] and expiry_dt > datetime.now(timezone.utc) if expiry_dt else False\n            status_emoji = \"👑\" if is_prem_active else \"🆓\"\n            text += (\n                f\"{status_emoji} ID: `{u_dict['user_id']}` Name: {u_dict['first_name'] or 'N/A'} (@{u_dict['username'] or 'N/A'})\\n\"\n                f\"   Premium: {'Yes' if is_prem_active else 'No'} (Expires: {expiry_str})\\n\"\n                f\"   Joined: {u_dict['join_date'].strftime('%Y-%m-%d')}\\n---\\n\"\n            )\n            count += 1\n            if len(text) > 3500: # Telegram message limit is 4096\n                query.message.reply_text(text, parse_mode=ParseMode.MARKDOWN) # Send current chunk\n                text = f\"(Continuation of users list... {count} users shown so far)\\n\\n\"\n        if text:\n            query.edit_message_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=admin_panel_keyboard())\n\n    elif data == CB_ADMIN_VIEW_CONNECTIONS:\n        if user_id != ADMIN_TELEGRAM_ID: query.answer(\"Unauthorized!\", show_alert=True); return\n        conns = get_all_active_connections_for_admin()\n        if not conns:\n            query.edit_message_text(\"No active channel-to-group connections found.\", reply_markup=admin_panel_keyboard())\n            return\n        text = \"🔗 **All Active User Connections:**\\n\\n\"\n        count = 0\n        for c_dict in conns:\n            tg_chat_display = c_dict['telegram_chat_title'] or str(c_dict['telegram_chat_id'])\n            text += (\n                f\"👤 User: `{c_dict['user_id']}` (@{c_dict['user_username'] or 'N/A'})\\n\"\n                f\"  📺 YT: {c_dict['youtube_channel_name']} (`{c_dict['yt_api_id']}`)\\n\"\n                f\"  🔗 TG: {tg_chat_display} (`{c_dict['telegram_chat_id']}`)\\n\"\n                f\"  🗓️ Linked: YT on {c_dict['date_linked'].strftime('%Y-%m-%d')}, TG on {c_dict['date_mapped'].strftime('%Y-%m-%d')}\\n---\\n\"\n            )\n            count += 1\n            if len(text) > 3500:\n                query.message.reply_text(text, parse_mode=ParseMode.MARKDOWN)\n                text = f\"(Continuation of connections list... {count} connections shown so far)\\n\\n\"\n        if text:\n            query.edit_message_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=admin_panel_keyboard())\n\n    elif data == \"noop_info\": # For buttons that are just informational\n        query.answer(\"This is an informational message.\")\n\n    else:\n        logger.warning(f\"Unhandled callback query data from user {user_id}: {data}\")\n        query.answer(\"This action is not recognized or is part of an ongoing conversation.\")\n\n\n# ==============================================================================\n# SCHEDULED JOBS (via PTB JobQueue)\n# ==============================================================================\ndef check_new_yt_videos_job(context: CallbackContext):\n    logger.info(\"JOB: Checking for new YouTube videos...\")\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        # Get all distinct YouTube channels that have active user subscriptions and group mappings\n        cursor.execute('''\n            SELECT DISTINCT\n                yc.id as yt_channel_db_id,\n                yc.youtube_channel_id as yt_api_id,\n                yc.youtube_channel_name,\n                yc.last_fetched_video_id\n            FROM youtube_channels yc\n            JOIN user_youtube_subscriptions uys ON yc.id = uys.yt_channel_db_id\n            JOIN channel_group_mappings cgm ON uys.id = cgm.user_subscription_id\n            WHERE cgm.is_active = TRUE\n        ''')\n        active_db_channels = [dict(row) for row in cursor.fetchall()]\n    \n    if not active_db_channels:\n        logger.info(\"JOB: No active YouTube channels to check.\")\n        return\n\n    youtube_service = get_youtube_service()\n    if not youtube_service:\n        logger.error(\"JOB: YouTube API service unavailable. Skipping video check.\")\n        return\n\n    for db_channel in active_db_channels:\n        yt_channel_db_id = db_channel['yt_channel_db_id']\n        yt_api_id = db_channel['yt_api_id']\n        yt_channel_name = db_channel['youtube_channel_name']\n        last_known_video_id_from_db = db_channel['last_fetched_video_id']\n        logger.debug(f\"JOB: Checking channel '{yt_channel_name}' ({yt_api_id}), last known video: {last_known_video_id_from_db}\")\n\n        try:\n            latest_videos_from_api, error_msg = get_latest_videos_from_yt_channel(yt_api_id, count=5) # Fetch a few recent videos\n            if error_msg:\n                logger.error(f\"JOB: Failed to fetch videos for '{yt_channel_name}': {error_msg}\")\n                if \"quotaExceeded\" in error_msg:\n                     logger.critical(\"JOB: YOUTUBE API QUOTA EXCEEDED. Video checking will be impaired.\")\n                continue # Skip this channel on error\n\n            if not latest_videos_from_api:\n                logger.debug(f\"JOB: No videos found for '{yt_channel_name}' in this API check.\")\n                # Update last_checked time in DB even if no videos\n                with get_db_connection() as conn_update_time: \n                    conn_update_time.execute(\"UPDATE youtube_channels SET last_checked = CURRENT_TIMESTAMP WHERE id = ?\", (yt_channel_db_id,))\n                continue\n\n            new_videos_to_post_chronological = []\n            # API gives newest first. We want to find videos *newer* than last_known_video_id_from_db\n            # and process them in chronological (oldest new to newest new) order.\n            for video_from_api in reversed(latest_videos_from_api): # Process oldest of the fetched batch first\n                if video_from_api['id'] == last_known_video_id_from_db:\n                    # We've reached the last video we processed from previous run. Stop here for this video batch.\n                    # All videos *before* this one in reversed list (i.e. after it in original API list) are newer.\n                    break \n                # If last_known_video_id_from_db is None (first check for this channel), all fetched are potentially new.\n                # However, we only want to post a few, not all history. For first run, maybe only post the newest 1-2.\n                # For now, if no last_known, all are considered candidates before the break logic.\n                new_videos_to_post_chronological.append(video_from_api)\n            \n            # Special handling for the very first check of a channel (last_known_video_id_from_db is None)\n            if last_known_video_id_from_db is None and new_videos_to_post_chronological:\n                logger.info(f\"JOB: First check for '{yt_channel_name}'. Posting only the latest video found to avoid spam.\")\n                new_videos_to_post_chronological = [new_videos_to_post_chronological[-1]] # Keep only the newest one\n\n            newest_video_id_this_fetch = latest_videos_from_api[0]['id'] # ID of the absolute newest video from API\n\n            if new_videos_to_post_chronological:\n                logger.info(f\"JOB: Found {len(new_videos_to_post_chronological)} new video(s) for '{yt_channel_name}'. Posting chronologically.\")\n                for video_to_post in new_videos_to_post_chronological:\n                    _send_video_update_to_tg_chats(context, yt_channel_db_id, yt_channel_name, video_to_post)\n                    # Update DB with this video_to_post['id'] as last_fetched? \n                    # Better to update with newest_video_id_this_fetch *after* loop to prevent re-posting on error.\n            \n            # Update last_fetched_video_id in DB to the newest video ID from this API fetch, regardless of posting.\n            # This ensures we don't re-process if some videos were skipped (e.g. first run)\n            if newest_video_id_this_fetch != last_known_video_id_from_db:\n                 with get_db_connection() as conn_update_last:\n                    conn_update_last.execute(\"UPDATE youtube_channels SET last_fetched_video_id = ?, last_checked = CURRENT_TIMESTAMP WHERE id = ?\", \n                                        (newest_video_id_this_fetch, yt_channel_db_id))\n                    logger.debug(f\"JOB: Updated last_fetched_video_id for '{yt_channel_name}' to {newest_video_id_this_fetch}\")\n            else: # No change in newest video, just update last_checked\n                 with get_db_connection() as conn_update_time: \n                    conn_update_time.execute(\"UPDATE youtube_channels SET last_checked = CURRENT_TIMESTAMP WHERE id = ?\", (yt_channel_db_id,))\n\n        except Exception as e_channel_proc:\n            logger.error(f\"JOB: Unhandled error processing channel '{yt_channel_name}' ({yt_api_id}): {e_channel_proc}\", exc_info=True)\n        \n        time.sleep(YT_API_CALL_DELAY_SECONDS) # Be polite to YouTube API\n    logger.info(\"JOB: Finished checking for new YouTube videos.\")\n\ndef _send_video_update_to_tg_chats(context: CallbackContext, yt_channel_db_id, yt_channel_name_for_log, video_data):\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        cursor.execute('''\n            SELECT cgm.id as mapping_id, cgm.telegram_chat_id, cgm.telegram_chat_title\n            FROM channel_group_mappings cgm\n            JOIN user_youtube_subscriptions uys ON cgm.user_subscription_id = uys.id\n            WHERE uys.yt_channel_db_id = ? AND cgm.is_active = TRUE\n        ''', (yt_channel_db_id,))\n        linked_chats_to_post = [dict(row) for row in cursor.fetchall()]\n    \n    if not linked_chats_to_post:\n        logger.debug(f\"JOB: No active TG chats found for YT channel DB ID {yt_channel_db_id} to post video '{video_data['id']}'.\")\n        return\n\n    video_url = f\"https://www.youtube.com/watch?v={video_data['id']}\"\n    # Customize your message format here\n    message_text = (\n        f\"📢 New Video from **{yt_channel_name_for_log}**!\n\n\"\n        f\"🎬 **{video_data['title']}**\n\n\"\n        # f\"{video_data['description'][:150]}...\\n\\n\" # Optional: truncated description\n        f\"📺 Watch now: {video_url}\"\n    )\n\n    for chat_target in linked_chats_to_post:\n        tg_chat_id = chat_target['telegram_chat_id']\n        tg_chat_title = chat_target['telegram_chat_title'] or str(tg_chat_id)\n        mapping_id = chat_target['mapping_id']\n        try:\n            context.bot.send_message(\n                chat_id=tg_chat_id,\n                text=message_text,\n                parse_mode=ParseMode.MARKDOWN,\n                disable_web_page_preview=False # Show YouTube preview\n            )\n            logger.info(f\"JOB: Posted video '{video_data['title']}' to TG chat '{tg_chat_title}' ({tg_chat_id}).\")\n        except Unauthorized as e_unauth:\n            logger.warning(f\"JOB: Unauthorized to post to TG chat '{tg_chat_title}' ({tg_chat_id}). Deactivating mapping ID {mapping_id}. Error: {e_unauth}\")\n            deactivate_tg_chat_mapping(mapping_id, by_mapping_id=True)\n        except BadRequest as e_badreq:\n            if \"chat not found\" in str(e_badreq).lower() or \"bot was kicked\" in str(e_badreq).lower() or \"group migrated\" in str(e_badreq).lower() or \"not enough rights\" in str(e_badreq).lower() or \"bot is not a member\" in str(e_badreq).lower():\n                logger.warning(f\"JOB: Cannot post to TG chat '{tg_chat_title}' ({tg_chat_id}). Deactivating mapping ID {mapping_id}. Error: {e_badreq}\")\n                deactivate_tg_chat_mapping(mapping_id, by_mapping_id=True)\n            else:\n                 logger.error(f\"JOB: BadRequest posting video '{video_data['title']}' to TG chat '{tg_chat_title}' ({tg_chat_id}). Error: {e_badreq}\")\n        except TimedOut as e_timeout:\n            logger.warning(f\"JOB: Timeout posting video '{video_data['title']}' to TG chat '{tg_chat_title}' ({tg_chat_id}). Error: {e_timeout}. Will retry next cycle.\")\n        except Exception as e_general_post:\n            logger.error(f\"JOB: Unexpected error posting video '{video_data['title']}' to TG chat '{tg_chat_title}' ({tg_chat_id}). Error: {e_general_post}\", exc_info=True)\n        time.sleep(0.5) # Small delay between posts to different chats\n\ndef send_due_reminders_job(context: CallbackContext):\n    logger.debug(\"JOB: Checking for due reminders...\")\n    due_reminders = get_due_reminders_from_db()\n    if not due_reminders:\n        # logger.debug(\"JOB: No due reminders found.\")\n        return\n\n    logger.info(f\"JOB: Found {len(due_reminders)} due reminders to send.\")\n    for reminder in due_reminders:\n        message = (\n            f\"🔔 **Video Reminder!**\\n\\n\"\n            f\"You asked to be reminded about this video:\n\"\n            f\"🎬 **{reminder['video_title']}**\\n\"\n            f\"{reminder['youtube_video_url']}\"\n        )\n        try:\n            context.bot.send_message(chat_id=reminder['user_id'], text=message, parse_mode=ParseMode.MARKDOWN)\n            mark_reminder_as_sent_in_db(reminder['id'])\n            logger.info(f\"JOB: Sent reminder ID {reminder['id']} for video '{reminder['video_title']}' to user {reminder['user_id']}.\")\n        except Unauthorized: # Bot blocked by user\n            logger.warning(f\"JOB: User {reminder['user_id']} blocked the bot or is deactivated. Marking reminder ID {reminder['id']} as sent.\")\n            mark_reminder_as_sent_in_db(reminder['id']) # Avoid retrying for blocked users\n        except BadRequest as e:\n             if \"chat not found\" in str(e).lower() or \"user dehydrated\" in str(e).lower():\n                 logger.warning(f\"JOB: Chat not found for user {reminder['user_id']} (reminder {reminder['id']}). Marking as sent. Error: {e}\")\n                 mark_reminder_as_sent_in_db(reminder['id'])\n             else:\n                logger.error(f\"JOB: BadRequest sending reminder ID {reminder['id']} to user {reminder['user_id']}: {e}\")\n        except Exception as e_general_remind:\n            logger.error(f\"JOB: Failed to send reminder ID {reminder['id']} to user {reminder['user_id']}: {e_general_remind}\", exc_info=True)\n        time.sleep(0.3) # Small delay between reminder messages\n    logger.info(\"JOB: Finished sending due reminders.\")\n\ndef expire_premium_users_job(context: CallbackContext):\n    logger.info(f\"JOB: Checking for expired premium users...\")\n    now_utc = datetime.now(timezone.utc)\n    with get_db_connection() as conn:\n        cursor = conn.cursor()\n        cursor.execute('''\n            SELECT user_id, username, premium_expiry_date FROM users\n            WHERE is_premium = TRUE AND premium_expiry_date IS NOT NULL AND premium_expiry_date < ?\n        ''', (now_utc,))\n        expired_users_rows = cursor.fetchall()\n\n        if not expired_users_rows:\n            logger.info(\"JOB: No premium users found whose subscriptions have expired.\")\n            return\n\n        logger.info(f\"JOB: Found {len(expired_users_rows)} user(s) with expired premium subscriptions.\")\n        for user_row in expired_users_rows:\n            user_id_to_downgrade = user_row['user_id']\n            username_display = user_row['username'] or user_row['user_id']\n            try:\n                cursor.execute(\"UPDATE users SET is_premium = FALSE, premium_expiry_date = NULL WHERE user_id = ?\", (user_id_to_downgrade,))\n                # conn.commit() is handled by 'with' context manager upon successful block exit\n                logger.info(f\"JOB: Premium expired for user {username_display} (ID: {user_id_to_downgrade}). Downgraded to free tier in DB.\")\n                remove_or_mark_premium_user_from_sheet(user_id_to_downgrade, mark_as_expired=True)\n                try:\n                    context.bot.send_message(\n                        chat_id=user_id_to_downgrade,\n                        text=\"🔔 Your premium subscription for the YouTube Auto-Poster Bot has expired. You are now on the free tier. Use /upgrade to renew your premium access and continue enjoying enhanced features!\"\n                    )\n                except (Unauthorized, BadRequest) as e_notify_expiry:\n                    logger.warning(f\"JOB: Could not notify user {user_id_to_downgrade} about premium expiry: {e_notify_expiry}\")\n            except Exception as e_db_downgrade:\n                logger.error(f\"JOB: Database error downgrading user {user_id_to_downgrade}: {e_db_downgrade}\")\n                # conn.rollback() handled by 'with' context if an exception occurs\n    logger.info(\"JOB: Finished checking for expired premium users.\")\n\n# ==============================================================================\n# MAIN BOT SETUP AND EXECUTION\n# ==============================================================================\ndef main():\n    # --- Preliminary Configuration Checks ---\n    if not TELEGRAM_BOT_TOKEN or TELEGRAM_BOT_TOKEN == \"YOUR_TELEGRAM_BOT_TOKEN_HERE\":\n        logger.critical(\"FATAL: TELEGRAM_BOT_TOKEN is not configured. Bot cannot start.\")\n        return\n    if not YOUTUBE_API_KEY or YOUTUBE_API_KEY == \"YOUR_YOUTUBE_API_KEY_HERE\":\n        logger.critical(\"FATAL: YOUTUBE_API_KEY is not configured. Bot cannot start.\")\n        return\n    if ADMIN_TELEGRAM_ID == 0:\n        logger.warning(\"ADMIN_TELEGRAM_ID is not set. Admin features will not be restricted properly.\")\n    \n    # Check GSheet credentials file existence if path is set and not the placeholder\n    if GSHEET_SERVICE_ACCOUNT_FILE and GSHEET_SERVICE_ACCOUNT_FILE != 'YOUR_SERVICE_ACCOUNT_JSON_PATH_IN_COLAB':\n        if not os.path.exists(GSHEET_SERVICE_ACCOUNT_FILE):\n            logger.warning(f\"Google Sheets credential file '{GSHEET_SERVICE_ACCOUNT_FILE}' not found. Google Sheets features will be disabled or may fail.\")\n    elif GSHEET_SERVICE_ACCOUNT_FILE == 'YOUR_SERVICE_ACCOUNT_JSON_PATH_IN_COLAB':\n         logger.info(\"Google Sheets credential path is set to placeholder. Sheets features likely disabled until configured.\")\n\n    initialize_db() # Ensure database and tables exist\n    _get_gspread_client() # Try to initialize GSpread client early to catch config issues\n    get_youtube_service() # Try to initialize YouTube client early\n    get_razorpay_client() # Try to initialize Razorpay client early\n\n    updater = Updater(token=TELEGRAM_BOT_TOKEN, use_context=True)\n    dispatcher = updater.dispatcher\n    job_queue = updater.job_queue # Use PTB's JobQueue\n\n    # --- Set Bot Commands (for Telegram UI) ---\n    try:\n        updater.bot.set_my_commands(BOT_COMMANDS) # For regular users\n        # Admins will see these too, plus they have /admin command access checked internally\n        logger.info(\"Bot commands set successfully.\")\n    except TelegramError as e_set_cmd:\n        logger.warning(f\"Could not set bot commands: {e_set_cmd}\")\n\n    # --- Conversation Handlers Setup ---\n    # Reminder Conversation\n    reminder_convo_handler = ConversationHandler(\n        entry_points=[\n            CommandHandler(\"setreminder\", setreminder_command_handler, pass_args=True),\n            CallbackQueryHandler(reminder_ask_video_url_from_menu, pattern=f\"^{CB_SCHEDULE_REMINDER}$\")\n        ],\n        states={\n            ASK_REMINDER_VIDEO_URL: [MessageHandler(Filters.text & ~Filters.command, reminder_received_video_url)],\n            ASK_REMINDER_DURATION_MINUTES: [MessageHandler(Filters.text & ~Filters.command, reminder_received_duration_minutes)],\n        },\n        fallbacks=[\n            CallbackQueryHandler(cancel_conversation_handler, pattern=f\"^{CB_CANCEL_CONVERSATION}$\"),\n            CommandHandler(\"cancel\", cancel_conversation_handler)\n        ],\n        per_user=True, per_chat=True, # Store conversation state per user, per chat\n        conversation_timeout=timedelta(minutes=10).total_seconds()\n    )\n    # Add Group to YT Channel (from menu) Conversation\n    add_group_to_channel_convo_handler = ConversationHandler(\n        entry_points=[CallbackQueryHandler(add_group_to_channel_start_convo, pattern=f\"^{CB_ADD_GROUP_TO_CHANNEL_PREFIX}[0-9]+$\")],\n        states={\n            ASK_TG_CHAT_ID_FOR_LINKING: [MessageHandler(Filters.text & ~Filters.command, add_group_to_channel_received_tg_chat_id)]\n        },\n        fallbacks=[\n            CallbackQueryHandler(cancel_conversation_handler, pattern=f\"^{CB_CANCEL_CONVERSATION}$\"),\n            CommandHandler(\"cancel\", cancel_conversation_handler)\n        ],\n        per_user=True, per_chat=True,\n        conversation_timeout=timedelta(minutes=5).total_seconds()\n    )\n    # Admin Manual Upgrade Conversation\n    admin_upgrade_convo_handler = ConversationHandler(\n        entry_points=[CallbackQueryHandler(admin_manual_upgrade_start, pattern=f\"^{CB_ADMIN_MANUAL_UPGRADE_START}$\")],\n        states={\n            ASK_ADMIN_UPGRADE_USER_ID: [MessageHandler(Filters.text & ~Filters.command, admin_manual_upgrade_received_user_id)],\n            ASK_ADMIN_UPGRADE_MONTHS: [MessageHandler(Filters.text & ~Filters.command, admin_manual_upgrade_received_months)],\n        },\n        fallbacks=[\n            CallbackQueryHandler(cancel_conversation_handler, pattern=f\"^{CB_CANCEL_CONVERSATION}$\"),\n             CallbackQueryHandler(cancel_conversation_handler, pattern=f\"^{CB_ADMIN_PANEL}$\"), # If cancel button on prompt links back to admin panel\n            CommandHandler(\"cancel\", cancel_conversation_handler)\n        ],\n        per_user=True, per_chat=False, # Admin actions are per admin user, not tied to a specific chat with bot\n        conversation_timeout=timedelta(minutes=5).total_seconds()\n    )\n    # Admin Manual Downgrade (TODO: Implement fully if needed, similar to upgrade)\n\n    # --- Register Handlers (Order Matters for Broad Filters like MessageHandler) ---\n    # Commands (specific first)\n    dispatcher.add_handler(CommandHandler(\"start\", start_command_handler, pass_args=True))\n    dispatcher.add_handler(CommandHandler(\"help\", help_command_handler))\n    dispatcher.add_handler(CommandHandler(\"addchannel\", addchannel_command_handler, pass_args=True))\n    dispatcher.add_handler(CommandHandler(\"mychannels\", callback_query_router, pass_args=False)) # Simulate CB_MY_CHANNELS click\n    # Add /mychannels to send the keyboard directly if user types command\n    dispatcher.add_handler(CommandHandler(\"upgrade\", callback_query_router, pass_args=False)) # Simulate CB_UPGRADE_OPTIONS click\n    dispatcher.add_handler(CommandHandler(\"myreferral\", my_referral_command_handler))\n    dispatcher.add_handler(CommandHandler(\"admin\", admin_command_handler))\n    dispatcher.add_handler(CommandHandler(\"simpayment\", simulate_payment_command_handler, pass_args=True))\n    \n    # Conversation Handlers (must be added before general CallbackQueryHandler if entry is CBQ)\n    dispatcher.add_handler(reminder_convo_handler)\n    dispatcher.add_handler(add_group_to_channel_convo_handler)\n    dispatcher.add_handler(admin_upgrade_convo_handler)\n    # dispatcher.add_handler(admin_downgrade_convo_handler)\n\n    # Callback Query Handler (for all inline button presses not part of a conversation entry)\n    dispatcher.add_handler(CallbackQueryHandler(callback_query_router))\n\n    # Optional: A general message handler for unknown commands or text (must be last)\n    # dispatcher.add_handler(MessageHandler(Filters.text & ~Filters.command, unknown_text_handler))\n\n    # --- Schedule Background Jobs --- \n    job_queue.run_repeating(check_new_yt_videos_job, interval=timedelta(minutes=VIDEO_CHECK_INTERVAL_MINUTES).total_seconds(), first=timedelta(seconds=15).total_seconds(), name=\"YTVideoCheck\")\n    job_queue.run_repeating(send_due_reminders_job, interval=timedelta(minutes=REMINDER_CHECK_INTERVAL_MINUTES).total_seconds(), first=timedelta(seconds=5).total_seconds(), name=\"RemindersSend\")\n    job_queue.run_repeating(expire_premium_users_job, interval=timedelta(hours=PREMIUM_EXPIRY_CHECK_INTERVAL_HOURS).total_seconds(), first=timedelta(minutes=1).total_seconds(), name=\"PremiumExpiryCheck\")\n    logger.info(f\"Scheduled jobs: Video Check every {VIDEO_CHECK_INTERVAL_MINUTES}m, Reminders every {REMINDER_CHECK_INTERVAL_MINUTES}m, Premium Expiry every {PREMIUM_EXPIRY_CHECK_INTERVAL_HOURS}h.\")\n\n    # --- Start the Bot ---\n    logger.info(\"Bot starting polling...\")\n    updater.start_polling(allowed_updates=Update.ALL_TYPES) # Get all update types\n    updater.idle() # Keep the bot running until Ctrl+C\n    logger.info(\"Bot stopped.\")\n\nif __name__ == '__main__':\n    main()\n"
}